import {
  getInjectedMagicEdenProvider
} from "./chunk-2A5V5VD2.js";
import {
  getInjectedXDEFIProvider
} from "./chunk-HDO5EHV6.js";
import {
  getInjectedPhantomProvider
} from "./chunk-S5MW2NDX.js";
import {
  getInjectedRainbowProvider
} from "./chunk-RSK7R2KP.js";
import {
  AbstractWallet,
  ENTRYPOINT_ADDRESS,
  ERC6551_REGISTRY,
  checkContractWalletSignature,
  getAnalyticsHeaders,
  require_dist
} from "./chunk-6KCAJ4F5.js";
import {
  getInjectedCoin98Provider
} from "./chunk-GMJ2LSFM.js";
import {
  ThirdwebSDK
} from "./chunk-5WVVQIJW.js";
import {
  WagmiAdapter
} from "./chunk-KU45NJHX.js";
import {
  D,
  D2,
  Kn,
  Kt,
  Kt2,
  Mr,
  N,
  V,
  _,
  esm_exports,
  formatJsonRpcError,
  formatJsonRpcRequest,
  formatJsonRpcResult,
  isJsonRpcError,
  isJsonRpcRequest,
  isJsonRpcResponse,
  isJsonRpcResult,
  ms,
  require_browser,
  require_cjs,
  require_cjs2,
  require_random,
  require_sha256,
  tr,
  ws
} from "./chunk-JMY4HDQL.js";
import {
  getInjectedOKXProvider
} from "./chunk-P6NEBXWD.js";
import {
  getInjectedCoreWalletProvider
} from "./chunk-C2LG6LUM.js";
import {
  getInjectedOneKeyProvider
} from "./chunk-LNS5HABE.js";
import {
  getInjectedCryptoDefiWalletProvider
} from "./chunk-3KURTY6X.js";
import {
  getInjectedRabbyProvider
} from "./chunk-GI363HME.js";
import {
  getInjectedMetamaskProvider
} from "./chunk-7NOJMCWO.js";
import {
  walletIds
} from "./chunk-IM5F35UJ.js";
import {
  assertWindowEthereum
} from "./chunk-B2TBXXRZ.js";
import {
  _defineProperty
} from "./chunk-HDD45CGW.js";
import {
  aesDecryptCompat,
  aesEncrypt,
  getChainProvider,
  isContractDeployed
} from "./chunk-PKZFZVQJ.js";
import {
  require_utils
} from "./chunk-TYGHEAKX.js";
import {
  eventemitter3_default
} from "./chunk-NBFJ3KHJ.js";
import {
  require_events
} from "./chunk-774J2MD3.js";
import {
  Wallet,
  ethers_exports,
  init_lib7 as init_lib3,
  utils_exports
} from "./chunk-KC6NNU7E.js";
import {
  BigNumber,
  hashMessage,
  init_lib11 as init_lib,
  init_lib15 as init_lib2,
  recoverAddress
} from "./chunk-C56U6TOF.js";
import {
  c1,
  defaultChains,
  getValidChainRPCs,
  updateChainRPCs
} from "./chunk-K6EL5C3Z.js";
import {
  init_shim,
  require_buffer
} from "./chunk-6E35MBRA.js";
import {
  __toESM
} from "./chunk-IJ7IQSKN.js";

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_shim();

// node_modules/@walletconnect/web3wallet/dist/index.es.js
init_shim();

// node_modules/@walletconnect/auth-client/dist/index.es.js
init_shim();
var import_logger = __toESM(require_cjs2());
var import_events = __toESM(require_events());
var import_time = __toESM(require_cjs());
init_lib();
init_lib2();
var import_isomorphic_unfetch = __toESM(require_browser());
var import_random = __toESM(require_random());
var import_sha256 = __toESM(require_sha256());
var G = class {
  constructor(t) {
    this.client = t;
  }
};
var H = class {
  constructor(t) {
    this.opts = t;
  }
};
var Y = "https://rpc.walletconnect.com/v1";
var R = { wc_authRequest: { req: { ttl: import_time.ONE_DAY, prompt: true, tag: 3e3 }, res: { ttl: import_time.ONE_DAY, prompt: false, tag: 3001 } } };
var U = { min: import_time.FIVE_MINUTES, max: import_time.SEVEN_DAYS };
var $ = "wc";
var Q = 1;
var Z = "auth";
var B = "authClient";
var F = `${$}@${1}:${Z}:`;
var x = `${F}:PUB_KEY`;
function z(r) {
  return r == null ? void 0 : r.split(":");
}
function Ze(r) {
  const t = r && z(r);
  if (t)
    return t[3];
}
function We(r) {
  const t = r && z(r);
  if (t)
    return t[2] + ":" + t[3];
}
function W(r) {
  const t = r && z(r);
  if (t)
    return t.pop();
}
async function et(r, t, e, i, n) {
  switch (e.t) {
    case "eip191":
      return tt(r, t, e.s);
    case "eip1271":
      return await rt(r, t, e.s, i, n);
    default:
      throw new Error(`verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${e.t}`);
  }
}
function tt(r, t, e) {
  return recoverAddress(hashMessage(t), e).toLowerCase() === r.toLowerCase();
}
async function rt(r, t, e, i, n) {
  try {
    const s = "0x1626ba7e", o2 = "0000000000000000000000000000000000000000000000000000000000000040", u = "0000000000000000000000000000000000000000000000000000000000000041", a = e.substring(2), c = hashMessage(t).substring(2), h2 = s + c + o2 + u + a, f2 = await (0, import_isomorphic_unfetch.default)(`${Y}/?chainId=${i}&projectId=${n}`, { method: "POST", body: JSON.stringify({ id: it(), jsonrpc: "2.0", method: "eth_call", params: [{ to: r, data: h2 }, "latest"] }) }), { result: p2 } = await f2.json();
    return p2 ? p2.slice(0, s.length).toLowerCase() === s.toLowerCase() : false;
  } catch (s) {
    return console.error("isValidEip1271Signature: ", s), false;
  }
}
function it() {
  return Date.now() + Math.floor(Math.random() * 1e3);
}
function ee(r) {
  return r.getAll().filter((t) => "requester" in t);
}
function te(r, t) {
  return ee(r).find((e) => e.id === t);
}
function nt(r) {
  const t = Kt(r.aud), e = new RegExp(`${r.domain}`).test(r.aud), i = !!r.nonce, n = r.type ? r.type === "eip4361" : true, s = r.expiry;
  if (s && !tr(s, U)) {
    const { message: o2 } = N("MISSING_OR_INVALID", `request() expiry: ${s}. Expiry must be a number (in seconds) between ${U.min} and ${U.max}`);
    throw new Error(o2);
  }
  return !!(t && e && i && n);
}
function st(r, t) {
  return !!te(t, r.id);
}
function ot(r = 0) {
  return globalThis.Buffer != null && globalThis.Buffer.allocUnsafe != null ? globalThis.Buffer.allocUnsafe(r) : new Uint8Array(r);
}
function ut(r, t) {
  if (r.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var e = new Uint8Array(256), i = 0; i < e.length; i++)
    e[i] = 255;
  for (var n = 0; n < r.length; n++) {
    var s = r.charAt(n), o2 = s.charCodeAt(0);
    if (e[o2] !== 255)
      throw new TypeError(s + " is ambiguous");
    e[o2] = n;
  }
  var u = r.length, a = r.charAt(0), c = Math.log(u) / Math.log(256), h2 = Math.log(256) / Math.log(u);
  function f2(D4) {
    if (D4 instanceof Uint8Array || (ArrayBuffer.isView(D4) ? D4 = new Uint8Array(D4.buffer, D4.byteOffset, D4.byteLength) : Array.isArray(D4) && (D4 = Uint8Array.from(D4))), !(D4 instanceof Uint8Array))
      throw new TypeError("Expected Uint8Array");
    if (D4.length === 0)
      return "";
    for (var l2 = 0, m = 0, E2 = 0, y2 = D4.length; E2 !== y2 && D4[E2] === 0; )
      E2++, l2++;
    for (var w2 = (y2 - E2) * h2 + 1 >>> 0, g2 = new Uint8Array(w2); E2 !== y2; ) {
      for (var C2 = D4[E2], _3 = 0, b2 = w2 - 1; (C2 !== 0 || _3 < m) && b2 !== -1; b2--, _3++)
        C2 += 256 * g2[b2] >>> 0, g2[b2] = C2 % u >>> 0, C2 = C2 / u >>> 0;
      if (C2 !== 0)
        throw new Error("Non-zero carry");
      m = _3, E2++;
    }
    for (var v = w2 - m; v !== w2 && g2[v] === 0; )
      v++;
    for (var q2 = a.repeat(l2); v < w2; ++v)
      q2 += r.charAt(g2[v]);
    return q2;
  }
  function p2(D4) {
    if (typeof D4 != "string")
      throw new TypeError("Expected String");
    if (D4.length === 0)
      return new Uint8Array();
    var l2 = 0;
    if (D4[l2] !== " ") {
      for (var m = 0, E2 = 0; D4[l2] === a; )
        m++, l2++;
      for (var y2 = (D4.length - l2) * c + 1 >>> 0, w2 = new Uint8Array(y2); D4[l2]; ) {
        var g2 = e[D4.charCodeAt(l2)];
        if (g2 === 255)
          return;
        for (var C2 = 0, _3 = y2 - 1; (g2 !== 0 || C2 < E2) && _3 !== -1; _3--, C2++)
          g2 += u * w2[_3] >>> 0, w2[_3] = g2 % 256 >>> 0, g2 = g2 / 256 >>> 0;
        if (g2 !== 0)
          throw new Error("Non-zero carry");
        E2 = C2, l2++;
      }
      if (D4[l2] !== " ") {
        for (var b2 = y2 - E2; b2 !== y2 && w2[b2] === 0; )
          b2++;
        for (var v = new Uint8Array(m + (y2 - b2)), q2 = m; b2 !== y2; )
          v[q2++] = w2[b2++];
        return v;
      }
    }
  }
  function A2(D4) {
    var l2 = p2(D4);
    if (l2)
      return l2;
    throw new Error(`Non-${t} character`);
  }
  return { encode: f2, decodeUnsafe: p2, decode: A2 };
}
var at = ut;
var Dt = at;
var re = (r) => {
  if (r instanceof Uint8Array && r.constructor.name === "Uint8Array")
    return r;
  if (r instanceof ArrayBuffer)
    return new Uint8Array(r);
  if (ArrayBuffer.isView(r))
    return new Uint8Array(r.buffer, r.byteOffset, r.byteLength);
  throw new Error("Unknown type, must be binary type");
};
var ct = (r) => new TextEncoder().encode(r);
var ht = (r) => new TextDecoder().decode(r);
var lt = class {
  constructor(t, e, i) {
    this.name = t, this.prefix = e, this.baseEncode = i;
  }
  encode(t) {
    if (t instanceof Uint8Array)
      return `${this.prefix}${this.baseEncode(t)}`;
    throw Error("Unknown type, must be binary type");
  }
};
var dt = class {
  constructor(t, e, i) {
    if (this.name = t, this.prefix = e, e.codePointAt(0) === void 0)
      throw new Error("Invalid prefix character");
    this.prefixCodePoint = e.codePointAt(0), this.baseDecode = i;
  }
  decode(t) {
    if (typeof t == "string") {
      if (t.codePointAt(0) !== this.prefixCodePoint)
        throw Error(`Unable to decode multibase string ${JSON.stringify(t)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
      return this.baseDecode(t.slice(this.prefix.length));
    } else
      throw Error("Can only multibase decode strings");
  }
  or(t) {
    return ie(this, t);
  }
};
var pt = class {
  constructor(t) {
    this.decoders = t;
  }
  or(t) {
    return ie(this, t);
  }
  decode(t) {
    const e = t[0], i = this.decoders[e];
    if (i)
      return i.decode(t);
    throw RangeError(`Unable to decode multibase string ${JSON.stringify(t)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
  }
};
var ie = (r, t) => new pt({ ...r.decoders || { [r.prefix]: r }, ...t.decoders || { [t.prefix]: t } });
var ft = class {
  constructor(t, e, i, n) {
    this.name = t, this.prefix = e, this.baseEncode = i, this.baseDecode = n, this.encoder = new lt(t, e, i), this.decoder = new dt(t, e, n);
  }
  encode(t) {
    return this.encoder.encode(t);
  }
  decode(t) {
    return this.decoder.decode(t);
  }
};
var O = ({ name: r, prefix: t, encode: e, decode: i }) => new ft(r, t, e, i);
var T = ({ prefix: r, name: t, alphabet: e }) => {
  const { encode: i, decode: n } = Dt(e, t);
  return O({ prefix: r, name: t, encode: i, decode: (s) => re(n(s)) });
};
var gt = (r, t, e, i) => {
  const n = {};
  for (let h2 = 0; h2 < t.length; ++h2)
    n[t[h2]] = h2;
  let s = r.length;
  for (; r[s - 1] === "="; )
    --s;
  const o2 = new Uint8Array(s * e / 8 | 0);
  let u = 0, a = 0, c = 0;
  for (let h2 = 0; h2 < s; ++h2) {
    const f2 = n[r[h2]];
    if (f2 === void 0)
      throw new SyntaxError(`Non-${i} character`);
    a = a << e | f2, u += e, u >= 8 && (u -= 8, o2[c++] = 255 & a >> u);
  }
  if (u >= e || 255 & a << 8 - u)
    throw new SyntaxError("Unexpected end of data");
  return o2;
};
var Et = (r, t, e) => {
  const i = t[t.length - 1] === "=", n = (1 << e) - 1;
  let s = "", o2 = 0, u = 0;
  for (let a = 0; a < r.length; ++a)
    for (u = u << 8 | r[a], o2 += 8; o2 > e; )
      o2 -= e, s += t[n & u >> o2];
  if (o2 && (s += t[n & u << e - o2]), i)
    for (; s.length * e & 7; )
      s += "=";
  return s;
};
var d = ({ name: r, prefix: t, bitsPerChar: e, alphabet: i }) => O({ prefix: t, name: r, encode(n) {
  return Et(n, i, e);
}, decode(n) {
  return gt(n, i, e, r);
} });
var bt = O({ prefix: "\0", name: "identity", encode: (r) => ht(r), decode: (r) => ct(r) });
var yt = Object.freeze({ __proto__: null, identity: bt });
var wt = d({ prefix: "0", name: "base2", alphabet: "01", bitsPerChar: 1 });
var Ct = Object.freeze({ __proto__: null, base2: wt });
var mt = d({ prefix: "7", name: "base8", alphabet: "01234567", bitsPerChar: 3 });
var vt = Object.freeze({ __proto__: null, base8: mt });
var At = T({ prefix: "9", name: "base10", alphabet: "0123456789" });
var _t = Object.freeze({ __proto__: null, base10: At });
var xt = d({ prefix: "f", name: "base16", alphabet: "0123456789abcdef", bitsPerChar: 4 });
var Rt = d({ prefix: "F", name: "base16upper", alphabet: "0123456789ABCDEF", bitsPerChar: 4 });
var Ft = Object.freeze({ __proto__: null, base16: xt, base16upper: Rt });
var Tt = d({ prefix: "b", name: "base32", alphabet: "abcdefghijklmnopqrstuvwxyz234567", bitsPerChar: 5 });
var It = d({ prefix: "B", name: "base32upper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567", bitsPerChar: 5 });
var qt = d({ prefix: "c", name: "base32pad", alphabet: "abcdefghijklmnopqrstuvwxyz234567=", bitsPerChar: 5 });
var Ut = d({ prefix: "C", name: "base32padupper", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=", bitsPerChar: 5 });
var Ot = d({ prefix: "v", name: "base32hex", alphabet: "0123456789abcdefghijklmnopqrstuv", bitsPerChar: 5 });
var St = d({ prefix: "V", name: "base32hexupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV", bitsPerChar: 5 });
var Pt = d({ prefix: "t", name: "base32hexpad", alphabet: "0123456789abcdefghijklmnopqrstuv=", bitsPerChar: 5 });
var Nt = d({ prefix: "T", name: "base32hexpadupper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=", bitsPerChar: 5 });
var $t = d({ prefix: "h", name: "base32z", alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769", bitsPerChar: 5 });
var Bt = Object.freeze({ __proto__: null, base32: Tt, base32upper: It, base32pad: qt, base32padupper: Ut, base32hex: Ot, base32hexupper: St, base32hexpad: Pt, base32hexpadupper: Nt, base32z: $t });
var zt = T({ prefix: "k", name: "base36", alphabet: "0123456789abcdefghijklmnopqrstuvwxyz" });
var jt = T({ prefix: "K", name: "base36upper", alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ" });
var Mt = Object.freeze({ __proto__: null, base36: zt, base36upper: jt });
var Lt = T({ name: "base58btc", prefix: "z", alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz" });
var Kt3 = T({ name: "base58flickr", prefix: "Z", alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ" });
var Vt = Object.freeze({ __proto__: null, base58btc: Lt, base58flickr: Kt3 });
var kt = d({ prefix: "m", name: "base64", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", bitsPerChar: 6 });
var Jt = d({ prefix: "M", name: "base64pad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", bitsPerChar: 6 });
var Xt = d({ prefix: "u", name: "base64url", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_", bitsPerChar: 6 });
var Gt = d({ prefix: "U", name: "base64urlpad", alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=", bitsPerChar: 6 });
var Ht = Object.freeze({ __proto__: null, base64: kt, base64pad: Jt, base64url: Xt, base64urlpad: Gt });
var ne = Array.from("\u{1F680}\u{1FA90}\u2604\u{1F6F0}\u{1F30C}\u{1F311}\u{1F312}\u{1F313}\u{1F314}\u{1F315}\u{1F316}\u{1F317}\u{1F318}\u{1F30D}\u{1F30F}\u{1F30E}\u{1F409}\u2600\u{1F4BB}\u{1F5A5}\u{1F4BE}\u{1F4BF}\u{1F602}\u2764\u{1F60D}\u{1F923}\u{1F60A}\u{1F64F}\u{1F495}\u{1F62D}\u{1F618}\u{1F44D}\u{1F605}\u{1F44F}\u{1F601}\u{1F525}\u{1F970}\u{1F494}\u{1F496}\u{1F499}\u{1F622}\u{1F914}\u{1F606}\u{1F644}\u{1F4AA}\u{1F609}\u263A\u{1F44C}\u{1F917}\u{1F49C}\u{1F614}\u{1F60E}\u{1F607}\u{1F339}\u{1F926}\u{1F389}\u{1F49E}\u270C\u2728\u{1F937}\u{1F631}\u{1F60C}\u{1F338}\u{1F64C}\u{1F60B}\u{1F497}\u{1F49A}\u{1F60F}\u{1F49B}\u{1F642}\u{1F493}\u{1F929}\u{1F604}\u{1F600}\u{1F5A4}\u{1F603}\u{1F4AF}\u{1F648}\u{1F447}\u{1F3B6}\u{1F612}\u{1F92D}\u2763\u{1F61C}\u{1F48B}\u{1F440}\u{1F62A}\u{1F611}\u{1F4A5}\u{1F64B}\u{1F61E}\u{1F629}\u{1F621}\u{1F92A}\u{1F44A}\u{1F973}\u{1F625}\u{1F924}\u{1F449}\u{1F483}\u{1F633}\u270B\u{1F61A}\u{1F61D}\u{1F634}\u{1F31F}\u{1F62C}\u{1F643}\u{1F340}\u{1F337}\u{1F63B}\u{1F613}\u2B50\u2705\u{1F97A}\u{1F308}\u{1F608}\u{1F918}\u{1F4A6}\u2714\u{1F623}\u{1F3C3}\u{1F490}\u2639\u{1F38A}\u{1F498}\u{1F620}\u261D\u{1F615}\u{1F33A}\u{1F382}\u{1F33B}\u{1F610}\u{1F595}\u{1F49D}\u{1F64A}\u{1F639}\u{1F5E3}\u{1F4AB}\u{1F480}\u{1F451}\u{1F3B5}\u{1F91E}\u{1F61B}\u{1F534}\u{1F624}\u{1F33C}\u{1F62B}\u26BD\u{1F919}\u2615\u{1F3C6}\u{1F92B}\u{1F448}\u{1F62E}\u{1F646}\u{1F37B}\u{1F343}\u{1F436}\u{1F481}\u{1F632}\u{1F33F}\u{1F9E1}\u{1F381}\u26A1\u{1F31E}\u{1F388}\u274C\u270A\u{1F44B}\u{1F630}\u{1F928}\u{1F636}\u{1F91D}\u{1F6B6}\u{1F4B0}\u{1F353}\u{1F4A2}\u{1F91F}\u{1F641}\u{1F6A8}\u{1F4A8}\u{1F92C}\u2708\u{1F380}\u{1F37A}\u{1F913}\u{1F619}\u{1F49F}\u{1F331}\u{1F616}\u{1F476}\u{1F974}\u25B6\u27A1\u2753\u{1F48E}\u{1F4B8}\u2B07\u{1F628}\u{1F31A}\u{1F98B}\u{1F637}\u{1F57A}\u26A0\u{1F645}\u{1F61F}\u{1F635}\u{1F44E}\u{1F932}\u{1F920}\u{1F927}\u{1F4CC}\u{1F535}\u{1F485}\u{1F9D0}\u{1F43E}\u{1F352}\u{1F617}\u{1F911}\u{1F30A}\u{1F92F}\u{1F437}\u260E\u{1F4A7}\u{1F62F}\u{1F486}\u{1F446}\u{1F3A4}\u{1F647}\u{1F351}\u2744\u{1F334}\u{1F4A3}\u{1F438}\u{1F48C}\u{1F4CD}\u{1F940}\u{1F922}\u{1F445}\u{1F4A1}\u{1F4A9}\u{1F450}\u{1F4F8}\u{1F47B}\u{1F910}\u{1F92E}\u{1F3BC}\u{1F975}\u{1F6A9}\u{1F34E}\u{1F34A}\u{1F47C}\u{1F48D}\u{1F4E3}\u{1F942}");
var Yt = ne.reduce((r, t, e) => (r[e] = t, r), []);
var Qt = ne.reduce((r, t, e) => (r[t.codePointAt(0)] = e, r), []);
function Zt(r) {
  return r.reduce((t, e) => (t += Yt[e], t), "");
}
function Wt(r) {
  const t = [];
  for (const e of r) {
    const i = Qt[e.codePointAt(0)];
    if (i === void 0)
      throw new Error(`Non-base256emoji character: ${e}`);
    t.push(i);
  }
  return new Uint8Array(t);
}
var er = O({ prefix: "\u{1F680}", name: "base256emoji", encode: Zt, decode: Wt });
var tr2 = Object.freeze({ __proto__: null, base256emoji: er });
var rr = oe;
var se = 128;
var ir = 127;
var nr = ~ir;
var sr = Math.pow(2, 31);
function oe(r, t, e) {
  t = t || [], e = e || 0;
  for (var i = e; r >= sr; )
    t[e++] = r & 255 | se, r /= 128;
  for (; r & nr; )
    t[e++] = r & 255 | se, r >>>= 7;
  return t[e] = r | 0, oe.bytes = e - i + 1, t;
}
var or = j;
var ur = 128;
var ue = 127;
function j(r, i) {
  var e = 0, i = i || 0, n = 0, s = i, o2, u = r.length;
  do {
    if (s >= u)
      throw j.bytes = 0, new RangeError("Could not decode varint");
    o2 = r[s++], e += n < 28 ? (o2 & ue) << n : (o2 & ue) * Math.pow(2, n), n += 7;
  } while (o2 >= ur);
  return j.bytes = s - i, e;
}
var ar = Math.pow(2, 7);
var Dr = Math.pow(2, 14);
var cr = Math.pow(2, 21);
var hr = Math.pow(2, 28);
var lr = Math.pow(2, 35);
var dr = Math.pow(2, 42);
var pr = Math.pow(2, 49);
var fr = Math.pow(2, 56);
var gr = Math.pow(2, 63);
var Er = function(r) {
  return r < ar ? 1 : r < Dr ? 2 : r < cr ? 3 : r < hr ? 4 : r < lr ? 5 : r < dr ? 6 : r < pr ? 7 : r < fr ? 8 : r < gr ? 9 : 10;
};
var br = { encode: rr, decode: or, encodingLength: Er };
var ae = br;
var De = (r, t, e = 0) => (ae.encode(r, t, e), t);
var ce = (r) => ae.encodingLength(r);
var M = (r, t) => {
  const e = t.byteLength, i = ce(r), n = i + ce(e), s = new Uint8Array(n + e);
  return De(r, s, 0), De(e, s, i), s.set(t, n), new yr(r, e, t, s);
};
var yr = class {
  constructor(t, e, i, n) {
    this.code = t, this.size = e, this.digest = i, this.bytes = n;
  }
};
var he = ({ name: r, code: t, encode: e }) => new wr(r, t, e);
var wr = class {
  constructor(t, e, i) {
    this.name = t, this.code = e, this.encode = i;
  }
  digest(t) {
    if (t instanceof Uint8Array) {
      const e = this.encode(t);
      return e instanceof Uint8Array ? M(this.code, e) : e.then((i) => M(this.code, i));
    } else
      throw Error("Unknown type, must be binary type");
  }
};
var le = (r) => async (t) => new Uint8Array(await crypto.subtle.digest(r, t));
var Cr = he({ name: "sha2-256", code: 18, encode: le("SHA-256") });
var mr = he({ name: "sha2-512", code: 19, encode: le("SHA-512") });
var vr = Object.freeze({ __proto__: null, sha256: Cr, sha512: mr });
var de = 0;
var Ar = "identity";
var pe = re;
var _r = (r) => M(de, pe(r));
var xr = { code: de, name: Ar, encode: pe, digest: _r };
var Rr = Object.freeze({ __proto__: null, identity: xr });
new TextEncoder(), new TextDecoder();
var fe = { ...yt, ...Ct, ...vt, ..._t, ...Ft, ...Bt, ...Mt, ...Vt, ...Ht, ...tr2 };
({ ...vr, ...Rr });
function ge(r, t, e, i) {
  return { name: r, prefix: t, encoder: { name: r, prefix: t, encode: e }, decoder: { decode: i } };
}
var Ee = ge("utf8", "u", (r) => "u" + new TextDecoder("utf8").decode(r), (r) => new TextEncoder().encode(r.substring(1)));
var L = ge("ascii", "a", (r) => {
  let t = "a";
  for (let e = 0; e < r.length; e++)
    t += String.fromCharCode(r[e]);
  return t;
}, (r) => {
  r = r.substring(1);
  const t = ot(r.length);
  for (let e = 0; e < r.length; e++)
    t[e] = r.charCodeAt(e);
  return t;
});
var be = { utf8: Ee, "utf-8": Ee, hex: fe.base16, latin1: L, ascii: L, binary: L, ...fe };
function Fr(r, t = "utf8") {
  const e = be[t];
  if (!e)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r, "utf8") : e.decoder.decode(`${e.prefix}${r}`);
}
function Tr(r, t = "utf8") {
  const e = be[t];
  if (!e)
    throw new Error(`Unsupported encoding "${t}"`);
  return (t === "utf8" || t === "utf-8") && globalThis.Buffer != null && globalThis.Buffer.from != null ? globalThis.Buffer.from(r.buffer, r.byteOffset, r.byteLength).toString("utf8") : e.encoder.encode(r).substring(1);
}
var ye = "base16";
var we = "utf8";
function K(r) {
  const t = (0, import_sha256.hash)(Fr(r, we));
  return Tr(t, ye);
}
var Or = Object.defineProperty;
var Sr = Object.defineProperties;
var Pr = Object.getOwnPropertyDescriptors;
var Ce = Object.getOwnPropertySymbols;
var Nr = Object.prototype.hasOwnProperty;
var $r = Object.prototype.propertyIsEnumerable;
var me = (r, t, e) => t in r ? Or(r, t, { enumerable: true, configurable: true, writable: true, value: e }) : r[t] = e;
var I = (r, t) => {
  for (var e in t || (t = {}))
    Nr.call(t, e) && me(r, e, t[e]);
  if (Ce)
    for (var e of Ce(t))
      $r.call(t, e) && me(r, e, t[e]);
  return r;
};
var V2 = (r, t) => Sr(r, Pr(t));
var Br = class extends G {
  constructor(t) {
    super(t), this.initialized = false, this.name = "authEngine", this.init = () => {
      this.initialized || (this.registerRelayerEvents(), this.registerPairingEvents(), this.client.core.pairing.register({ methods: Object.keys(R) }), this.initialized = true);
    }, this.request = async (e, i) => {
      if (this.isInitialized(), !nt(e))
        throw new Error("Invalid request");
      if (i != null && i.topic)
        return await this.requestOnKnownPairing(i.topic, e);
      const { chainId: n, statement: s, aud: o2, domain: u, nonce: a, type: c, exp: h2, nbf: f2 } = e, { topic: p2, uri: A2 } = await this.client.core.pairing.create();
      this.client.logger.info({ message: "Generated new pairing", pairing: { topic: p2, uri: A2 } });
      const D4 = await this.client.core.crypto.generateKeyPair(), l2 = Kn(D4);
      await this.client.authKeys.set(x, { responseTopic: l2, publicKey: D4 }), await this.client.pairingTopics.set(l2, { topic: l2, pairingTopic: p2 }), await this.client.core.relayer.subscribe(l2), this.client.logger.info(`sending request to new pairing topic: ${p2}`);
      const m = await this.sendRequest(p2, "wc_authRequest", { payloadParams: { type: c != null ? c : "eip4361", chainId: n, statement: s, aud: o2, domain: u, version: "1", nonce: a, iat: new Date().toISOString(), exp: h2, nbf: f2 }, requester: { publicKey: D4, metadata: this.client.metadata } }, {}, e.expiry);
      return this.client.logger.info(`sent request to new pairing topic: ${p2}`), { uri: A2, id: m };
    }, this.respond = async (e, i) => {
      if (this.isInitialized(), !st(e, this.client.requests))
        throw new Error("Invalid response");
      const n = te(this.client.requests, e.id);
      if (!n)
        throw new Error(`Could not find pending auth request with id ${e.id}`);
      const s = n.requester.publicKey, o2 = await this.client.core.crypto.generateKeyPair(), u = Kn(s), a = { type: _, receiverPublicKey: s, senderPublicKey: o2 };
      if ("error" in e) {
        await this.sendError(n.id, u, e, a);
        return;
      }
      const c = { h: { t: "eip4361" }, p: V2(I({}, n.cacaoPayload), { iss: i }), s: e.signature };
      await this.sendResult(n.id, u, c, a), await this.client.core.pairing.activate({ topic: n.pairingTopic }), await this.client.requests.update(n.id, I({}, c));
    }, this.getPendingRequests = () => ee(this.client.requests), this.formatMessage = (e, i) => {
      this.client.logger.debug(`formatMessage, cacao is: ${JSON.stringify(e)}`);
      const n = `${e.domain} wants you to sign in with your Ethereum account:`, s = W(i), o2 = e.statement, u = `URI: ${e.aud}`, a = `Version: ${e.version}`, c = `Chain ID: ${Ze(i)}`, h2 = `Nonce: ${e.nonce}`, f2 = `Issued At: ${e.iat}`, p2 = e.exp ? `Expiry: ${e.exp}` : void 0, A2 = e.resources && e.resources.length > 0 ? `Resources:
${e.resources.map((D4) => `- ${D4}`).join(`
`)}` : void 0;
      return [n, s, "", o2, "", u, a, c, h2, f2, p2, A2].filter((D4) => D4 != null).join(`
`);
    }, this.setExpiry = async (e, i) => {
      this.client.core.pairing.pairings.keys.includes(e) && await this.client.core.pairing.updateExpiry({ topic: e, expiry: i }), this.client.core.expirer.set(e, i);
    }, this.sendRequest = async (e, i, n, s, o2) => {
      const u = formatJsonRpcRequest(i, n), a = await this.client.core.crypto.encode(e, u, s), c = R[i].req;
      if (o2 && (c.ttl = o2), this.client.core.history.set(e, u), D()) {
        const h2 = K(JSON.stringify(u));
        this.client.core.verify.register({ attestationId: h2 });
      }
      return await this.client.core.relayer.publish(e, a, V2(I({}, c), { internal: { throwOnFailedPublish: true } })), u.id;
    }, this.sendResult = async (e, i, n, s) => {
      const o2 = formatJsonRpcResult(e, n), u = await this.client.core.crypto.encode(i, o2, s), a = await this.client.core.history.get(i, e), c = R[a.request.method].res;
      return await this.client.core.relayer.publish(i, u, V2(I({}, c), { internal: { throwOnFailedPublish: true } })), await this.client.core.history.resolve(o2), o2.id;
    }, this.sendError = async (e, i, n, s) => {
      const o2 = formatJsonRpcError(e, n.error), u = await this.client.core.crypto.encode(i, o2, s), a = await this.client.core.history.get(i, e), c = R[a.request.method].res;
      return await this.client.core.relayer.publish(i, u, c), await this.client.core.history.resolve(o2), o2.id;
    }, this.requestOnKnownPairing = async (e, i) => {
      const n = this.client.core.pairing.pairings.getAll({ active: true }).find((A2) => A2.topic === e);
      if (!n)
        throw new Error(`Could not find pairing for provided topic ${e}`);
      const { publicKey: s } = this.client.authKeys.get(x), { chainId: o2, statement: u, aud: a, domain: c, nonce: h2, type: f2 } = i, p2 = await this.sendRequest(n.topic, "wc_authRequest", { payloadParams: { type: f2 != null ? f2 : "eip4361", chainId: o2, statement: u, aud: a, domain: c, version: "1", nonce: h2, iat: new Date().toISOString() }, requester: { publicKey: s, metadata: this.client.metadata } }, {}, i.expiry);
      return this.client.logger.info(`sent request to known pairing topic: ${n.topic}`), { id: p2 };
    }, this.onPairingCreated = (e) => {
      const i = this.getPendingRequests();
      if (i) {
        const n = Object.values(i).find((s) => s.pairingTopic === e.topic);
        n && this.handleAuthRequest(n);
      }
    }, this.onRelayEventRequest = (e) => {
      const { topic: i, payload: n } = e, s = n.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthRequest(i, n);
        default:
          return this.client.logger.info(`Unsupported request method ${s}`);
      }
    }, this.onRelayEventResponse = async (e) => {
      const { topic: i, payload: n } = e, s = (await this.client.core.history.get(i, n.id)).request.method;
      switch (s) {
        case "wc_authRequest":
          return this.onAuthResponse(i, n);
        default:
          return this.client.logger.info(`Unsupported response method ${s}`);
      }
    }, this.onAuthRequest = async (e, i) => {
      const { requester: n, payloadParams: s } = i.params;
      this.client.logger.info({ type: "onAuthRequest", topic: e, payload: i });
      const o2 = K(JSON.stringify(i)), u = await this.getVerifyContext(o2, this.client.metadata), a = { requester: n, pairingTopic: e, id: i.id, cacaoPayload: s, verifyContext: u };
      await this.client.requests.set(i.id, a), this.handleAuthRequest(a);
    }, this.handleAuthRequest = async (e) => {
      const { id: i, pairingTopic: n, requester: s, cacaoPayload: o2, verifyContext: u } = e;
      try {
        this.client.emit("auth_request", { id: i, topic: n, params: { requester: s, cacaoPayload: o2 }, verifyContext: u });
      } catch (a) {
        await this.sendError(e.id, e.pairingTopic, a), this.client.logger.error(a);
      }
    }, this.onAuthResponse = async (e, i) => {
      const { id: n } = i;
      if (this.client.logger.info({ type: "onAuthResponse", topic: e, response: i }), isJsonRpcResult(i)) {
        const { pairingTopic: s } = this.client.pairingTopics.get(e);
        await this.client.core.pairing.activate({ topic: s });
        const { s: o2, p: u } = i.result;
        await this.client.requests.set(n, I({ id: n, pairingTopic: s }, i.result));
        const a = this.formatMessage(u, u.iss);
        this.client.logger.debug(`reconstructed message:
`, JSON.stringify(a)), this.client.logger.debug("payload.iss:", u.iss), this.client.logger.debug("signature:", o2);
        const c = W(u.iss), h2 = We(u.iss);
        if (!c)
          throw new Error("Could not derive address from `payload.iss`");
        if (!h2)
          throw new Error("Could not derive chainId from `payload.iss`");
        this.client.logger.debug("walletAddress extracted from `payload.iss`:", c), await et(c, a, o2, h2, this.client.projectId) ? this.client.emit("auth_response", { id: n, topic: e, params: i }) : this.client.emit("auth_response", { id: n, topic: e, params: { message: "Invalid signature", code: -1 } });
      } else
        isJsonRpcError(i) && this.client.emit("auth_response", { id: n, topic: e, params: i });
    }, this.getVerifyContext = async (e, i) => {
      const n = { verified: { verifyUrl: i.verifyUrl || "", validation: "UNKNOWN", origin: i.url || "" } };
      try {
        const s = await this.client.core.verify.resolve({ attestationId: e, verifyUrl: i.verifyUrl });
        s && (n.verified.origin = s.origin, n.verified.isScam = s.isScam, n.verified.validation = origin === new URL(i.url).origin ? "VALID" : "INVALID");
      } catch (s) {
        this.client.logger.error(s);
      }
      return this.client.logger.info(`Verify context: ${JSON.stringify(n)}`), n;
    };
  }
  isInitialized() {
    if (!this.initialized) {
      const { message: t } = N("NOT_INITIALIZED", this.name);
      throw new Error(t);
    }
  }
  registerRelayerEvents() {
    this.client.core.relayer.on(D2.message, async (t) => {
      const { topic: e, message: i } = t, { responseTopic: n, publicKey: s } = this.client.authKeys.keys.includes(x) ? this.client.authKeys.get(x) : { responseTopic: void 0, publicKey: void 0 };
      if (n && e !== n) {
        this.client.logger.debug("[Auth] Ignoring message from unknown topic", e);
        return;
      }
      const o2 = await this.client.core.crypto.decode(e, i, { receiverPublicKey: s });
      isJsonRpcRequest(o2) ? (this.client.core.history.set(e, o2), this.onRelayEventRequest({ topic: e, payload: o2 })) : isJsonRpcResponse(o2) && (await this.client.core.history.resolve(o2), this.onRelayEventResponse({ topic: e, payload: o2 }));
    });
  }
  registerPairingEvents() {
    this.client.core.pairing.events.on(V.create, (t) => this.onPairingCreated(t));
  }
};
var S = class extends H {
  constructor(t) {
    super(t), this.protocol = $, this.version = Q, this.name = B, this.events = new import_events.EventEmitter(), this.emit = (i, n) => this.events.emit(i, n), this.on = (i, n) => this.events.on(i, n), this.once = (i, n) => this.events.once(i, n), this.off = (i, n) => this.events.off(i, n), this.removeListener = (i, n) => this.events.removeListener(i, n), this.request = async (i, n) => {
      try {
        return await this.engine.request(i, n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.respond = async (i, n) => {
      try {
        return await this.engine.respond(i, n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.getPendingRequests = () => {
      try {
        return this.engine.getPendingRequests();
      } catch (i) {
        throw this.logger.error(i.message), i;
      }
    }, this.formatMessage = (i, n) => {
      try {
        return this.engine.formatMessage(i, n);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    };
    const e = typeof t.logger < "u" && typeof t.logger != "string" ? t.logger : (0, import_logger.pino)((0, import_logger.getDefaultLoggerOptions)({ level: t.logger || "error" }));
    this.name = (t == null ? void 0 : t.name) || B, this.metadata = t.metadata, this.projectId = t.projectId, this.core = t.core || new Mr(t), this.logger = (0, import_logger.generateChildLogger)(e, this.name), this.authKeys = new Kt2(this.core, this.logger, "authKeys", F, () => x), this.pairingTopics = new Kt2(this.core, this.logger, "pairingTopics", F), this.requests = new Kt2(this.core, this.logger, "requests", F, (i) => i.id), this.engine = new Br(this);
  }
  static async init(t) {
    const e = new S(t);
    return await e.initialize(), e;
  }
  get context() {
    return (0, import_logger.getLoggerContext)(this.logger);
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.core.start(), await this.authKeys.init(), await this.requests.init(), await this.pairingTopics.init(), await this.engine.init(), this.logger.info("AuthClient Initialization Success"), this.logger.info({ authClient: this });
    } catch (t) {
      throw this.logger.info("AuthClient Initialization Failure"), this.logger.error(t.message), t;
    }
  }
};
var zr = S;

// node_modules/@walletconnect/web3wallet/dist/index.es.js
var l = { exports: {} };
var h = typeof Reflect == "object" ? Reflect : null;
var y = h && typeof h.apply == "function" ? h.apply : function(t, e, s) {
  return Function.prototype.apply.call(t, e, s);
};
var f;
h && typeof h.ownKeys == "function" ? f = h.ownKeys : Object.getOwnPropertySymbols ? f = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : f = function(t) {
  return Object.getOwnPropertyNames(t);
};
function I2(n) {
  console && console.warn && console.warn(n);
}
var w = Number.isNaN || function(t) {
  return t !== t;
};
function o() {
  o.init.call(this);
}
l.exports = o, l.exports.once = F2, o.EventEmitter = o, o.prototype._events = void 0, o.prototype._eventsCount = 0, o.prototype._maxListeners = void 0;
var L2 = 10;
function g(n) {
  if (typeof n != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof n);
}
Object.defineProperty(o, "defaultMaxListeners", { enumerable: true, get: function() {
  return L2;
}, set: function(n) {
  if (typeof n != "number" || n < 0 || w(n))
    throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + n + ".");
  L2 = n;
} }), o.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
}, o.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || w(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function _2(n) {
  return n._maxListeners === void 0 ? o.defaultMaxListeners : n._maxListeners;
}
o.prototype.getMaxListeners = function() {
  return _2(this);
}, o.prototype.emit = function(t) {
  for (var e = [], s = 1; s < arguments.length; s++)
    e.push(arguments[s]);
  var i = t === "error", a = this._events;
  if (a !== void 0)
    i = i && a.error === void 0;
  else if (!i)
    return false;
  if (i) {
    var r;
    if (e.length > 0 && (r = e[0]), r instanceof Error)
      throw r;
    var c = new Error("Unhandled error." + (r ? " (" + r.message + ")" : ""));
    throw c.context = r, c;
  }
  var u = a[t];
  if (u === void 0)
    return false;
  if (typeof u == "function")
    y(u, this, e);
  else
    for (var v = u.length, T2 = b(u, v), s = 0; s < v; ++s)
      y(T2[s], this, e);
  return true;
};
function S2(n, t, e, s) {
  var i, a, r;
  if (g(e), a = n._events, a === void 0 ? (a = n._events = /* @__PURE__ */ Object.create(null), n._eventsCount = 0) : (a.newListener !== void 0 && (n.emit("newListener", t, e.listener ? e.listener : e), a = n._events), r = a[t]), r === void 0)
    r = a[t] = e, ++n._eventsCount;
  else if (typeof r == "function" ? r = a[t] = s ? [e, r] : [r, e] : s ? r.unshift(e) : r.push(e), i = _2(n), i > 0 && r.length > i && !r.warned) {
    r.warned = true;
    var c = new Error("Possible EventEmitter memory leak detected. " + r.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    c.name = "MaxListenersExceededWarning", c.emitter = n, c.type = t, c.count = r.length, I2(c);
  }
  return n;
}
o.prototype.addListener = function(t, e) {
  return S2(this, t, e, false);
}, o.prototype.on = o.prototype.addListener, o.prototype.prependListener = function(t, e) {
  return S2(this, t, e, true);
};
function M2() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function C(n, t, e) {
  var s = { fired: false, wrapFn: void 0, target: n, type: t, listener: e }, i = M2.bind(s);
  return i.listener = e, s.wrapFn = i, i;
}
o.prototype.once = function(t, e) {
  return g(e), this.on(t, C(this, t, e)), this;
}, o.prototype.prependOnceListener = function(t, e) {
  return g(e), this.prependListener(t, C(this, t, e)), this;
}, o.prototype.removeListener = function(t, e) {
  var s, i, a, r, c;
  if (g(e), i = this._events, i === void 0)
    return this;
  if (s = i[t], s === void 0)
    return this;
  if (s === e || s.listener === e)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[t], i.removeListener && this.emit("removeListener", t, s.listener || e));
  else if (typeof s != "function") {
    for (a = -1, r = s.length - 1; r >= 0; r--)
      if (s[r] === e || s[r].listener === e) {
        c = s[r].listener, a = r;
        break;
      }
    if (a < 0)
      return this;
    a === 0 ? s.shift() : k(s, a), s.length === 1 && (i[t] = s[0]), i.removeListener !== void 0 && this.emit("removeListener", t, c || e);
  }
  return this;
}, o.prototype.off = o.prototype.removeListener, o.prototype.removeAllListeners = function(t) {
  var e, s, i;
  if (s = this._events, s === void 0)
    return this;
  if (s.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : s[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete s[t]), this;
  if (arguments.length === 0) {
    var a = Object.keys(s), r;
    for (i = 0; i < a.length; ++i)
      r = a[i], r !== "removeListener" && this.removeAllListeners(r);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (e = s[t], typeof e == "function")
    this.removeListener(t, e);
  else if (e !== void 0)
    for (i = e.length - 1; i >= 0; i--)
      this.removeListener(t, e[i]);
  return this;
};
function E(n, t, e) {
  var s = n._events;
  if (s === void 0)
    return [];
  var i = s[t];
  return i === void 0 ? [] : typeof i == "function" ? e ? [i.listener || i] : [i] : e ? z2(i) : b(i, i.length);
}
o.prototype.listeners = function(t) {
  return E(this, t, true);
}, o.prototype.rawListeners = function(t) {
  return E(this, t, false);
}, o.listenerCount = function(n, t) {
  return typeof n.listenerCount == "function" ? n.listenerCount(t) : O2.call(n, t);
}, o.prototype.listenerCount = O2;
function O2(n) {
  var t = this._events;
  if (t !== void 0) {
    var e = t[n];
    if (typeof e == "function")
      return 1;
    if (e !== void 0)
      return e.length;
  }
  return 0;
}
o.prototype.eventNames = function() {
  return this._eventsCount > 0 ? f(this._events) : [];
};
function b(n, t) {
  for (var e = new Array(t), s = 0; s < t; ++s)
    e[s] = n[s];
  return e;
}
function k(n, t) {
  for (; t + 1 < n.length; t++)
    n[t] = n[t + 1];
  n.pop();
}
function z2(n) {
  for (var t = new Array(n.length), e = 0; e < t.length; ++e)
    t[e] = n[e].listener || n[e];
  return t;
}
function F2(n, t) {
  return new Promise(function(e, s) {
    function i(r) {
      n.removeListener(t, a), s(r);
    }
    function a() {
      typeof n.removeListener == "function" && n.removeListener("error", i), e([].slice.call(arguments));
    }
    R2(n, t, a, { once: true }), t !== "error" && D3(n, i, { once: true });
  });
}
function D3(n, t, e) {
  typeof n.on == "function" && R2(n, "error", t, e);
}
function R2(n, t, e, s) {
  if (typeof n.on == "function")
    s.once ? n.once(t, e) : n.on(t, e);
  else if (typeof n.addEventListener == "function")
    n.addEventListener(t, function i(a) {
      s.once && n.removeEventListener(t, i), e(a);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof n);
}
var x2 = "wc";
var p = "Web3Wallet";
var U2 = `${x2}@2:${p}:`;
var G2 = class extends l.exports {
  constructor() {
    super();
  }
};
var P = class {
  constructor(t) {
    this.opts = t;
  }
};
var q = class {
  constructor(t) {
    this.client = t;
  }
};
var H2 = class extends q {
  constructor(t) {
    super(t), this.init = async () => {
      this.signClient = await ms.init({ core: this.client.core, metadata: this.client.metadata }), this.authClient = await zr.init({ core: this.client.core, projectId: "", metadata: this.client.metadata }), this.initializeEventListeners();
    }, this.pair = async (e) => {
      await this.client.core.pairing.pair(e);
    }, this.approveSession = async (e) => {
      const { topic: s, acknowledged: i } = await this.signClient.approve({ id: e.id, namespaces: e.namespaces });
      return await i(), this.signClient.session.get(s);
    }, this.rejectSession = async (e) => await this.signClient.reject(e), this.updateSession = async (e) => await (await this.signClient.update(e)).acknowledged(), this.extendSession = async (e) => await (await this.signClient.extend(e)).acknowledged(), this.respondSessionRequest = async (e) => await this.signClient.respond(e), this.disconnectSession = async (e) => await this.signClient.disconnect(e), this.emitSessionEvent = async (e) => await this.signClient.emit(e), this.getActiveSessions = () => this.signClient.session.getAll().reduce((e, s) => (e[s.topic] = s, e), {}), this.getPendingSessionProposals = () => this.signClient.proposal.getAll(), this.getPendingSessionRequests = () => this.signClient.getPendingSessionRequests(), this.respondAuthRequest = async (e, s) => await this.authClient.respond(e, s), this.getPendingAuthRequests = () => this.authClient.requests.getAll().filter((e) => "requester" in e), this.formatMessage = (e, s) => this.authClient.formatMessage(e, s), this.registerDeviceToken = (e) => this.client.core.echoClient.registerDeviceToken(e), this.onSessionRequest = (e) => {
      this.client.events.emit("session_request", e);
    }, this.onSessionProposal = (e) => {
      this.client.events.emit("session_proposal", e);
    }, this.onSessionDelete = (e) => {
      this.client.events.emit("session_delete", e);
    }, this.onAuthRequest = (e) => {
      this.client.events.emit("auth_request", e);
    }, this.onProposalExpire = (e) => {
      this.client.events.emit("proposal_expire", e);
    }, this.onSessionRequestExpire = (e) => {
      this.client.events.emit("session_request_expire", e);
    }, this.initializeEventListeners = () => {
      this.signClient.events.on("session_proposal", this.onSessionProposal), this.signClient.events.on("session_request", this.onSessionRequest), this.signClient.events.on("session_delete", this.onSessionDelete), this.authClient.on("auth_request", this.onAuthRequest), this.signClient.events.on("proposal_expire", this.onProposalExpire), this.signClient.events.on("session_request_expire", this.onSessionRequestExpire);
    }, this.signClient = {}, this.authClient = {};
  }
};
var Q2 = { decryptMessage: async (n) => {
  const t = { core: new Mr({ storageOptions: n.storageOptions, storage: n.storage }) };
  await t.core.crypto.init();
  const e = t.core.crypto.decode(n.topic, n.encryptedMessage);
  return t.core = null, e;
}, getMetadata: async (n) => {
  const t = { core: new Mr({ storageOptions: n.storageOptions, storage: n.storage }), sessionStore: null };
  t.sessionStore = new ws(t.core, t.core.logger), await t.sessionStore.init();
  const e = t.sessionStore.get(n.topic), s = e == null ? void 0 : e.peer.metadata;
  return t.core = null, t.sessionStore = null, s;
} };
var A = class extends P {
  constructor(n) {
    super(n), this.events = new l.exports(), this.on = (t, e) => this.events.on(t, e), this.once = (t, e) => this.events.once(t, e), this.off = (t, e) => this.events.off(t, e), this.removeListener = (t, e) => this.events.removeListener(t, e), this.pair = async (t) => {
      try {
        return await this.engine.pair(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.approveSession = async (t) => {
      try {
        return await this.engine.approveSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.rejectSession = async (t) => {
      try {
        return await this.engine.rejectSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.updateSession = async (t) => {
      try {
        return await this.engine.updateSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.extendSession = async (t) => {
      try {
        return await this.engine.extendSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.respondSessionRequest = async (t) => {
      try {
        return await this.engine.respondSessionRequest(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.disconnectSession = async (t) => {
      try {
        return await this.engine.disconnectSession(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.emitSessionEvent = async (t) => {
      try {
        return await this.engine.emitSessionEvent(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.getActiveSessions = () => {
      try {
        return this.engine.getActiveSessions();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionProposals = () => {
      try {
        return this.engine.getPendingSessionProposals();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.getPendingSessionRequests = () => {
      try {
        return this.engine.getPendingSessionRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.respondAuthRequest = async (t, e) => {
      try {
        return await this.engine.respondAuthRequest(t, e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.getPendingAuthRequests = () => {
      try {
        return this.engine.getPendingAuthRequests();
      } catch (t) {
        throw this.logger.error(t.message), t;
      }
    }, this.formatMessage = (t, e) => {
      try {
        return this.engine.formatMessage(t, e);
      } catch (s) {
        throw this.logger.error(s.message), s;
      }
    }, this.registerDeviceToken = (t) => {
      try {
        return this.engine.registerDeviceToken(t);
      } catch (e) {
        throw this.logger.error(e.message), e;
      }
    }, this.metadata = n.metadata, this.name = n.name || p, this.core = n.core, this.logger = this.core.logger, this.engine = new H2(this);
  }
  static async init(n) {
    const t = new A(n);
    return await t.initialize(), t;
  }
  async initialize() {
    this.logger.trace("Initialized");
    try {
      await this.engine.init(), this.logger.info("Web3Wallet Initialization Success");
    } catch (n) {
      throw this.logger.info("Web3Wallet Initialization Failure"), this.logger.error(n.message), n;
    }
  }
};
var d2 = A;
d2.notifications = Q2;
var V3 = d2;

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
init_lib3();

// node_modules/@thirdweb-dev/wallets/dist/wc-fbb7ab15.browser.esm.js
init_shim();
var TW_WC_PROJECT_ID = "145769e410f16970a79ff77b2d89a1e0";
var WC_RELAY_URL = "wss://relay.walletconnect.com";
var EIP155_SIGNING_METHODS = {
  PERSONAL_SIGN: "personal_sign",
  ETH_SIGN: "eth_sign",
  ETH_SIGN_TRANSACTION: "eth_signTransaction",
  ETH_SIGN_TYPED_DATA: "eth_signTypedData",
  ETH_SIGN_TYPED_DATA_V3: "eth_signTypedData_v3",
  ETH_SIGN_TYPED_DATA_V4: "eth_signTypedData_v4",
  ETH_SEND_TRANSACTION: "eth_sendTransaction",
  SWITCH_CHAIN: "wallet_switchEthereumChain"
};

// node_modules/@thirdweb-dev/wallets/dist/base-5f1fe47c.browser.esm.js
init_shim();
var PREFIX = "__TW__";
var AsyncLocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return new Promise((res) => {
      res(localStorage.getItem(`${PREFIX}/${this.name}/${key}`));
    });
  }
  setItem(key, value) {
    return new Promise((res, rej) => {
      try {
        localStorage.setItem(`${PREFIX}/${this.name}/${key}`, value);
        res();
      } catch (e) {
        rej(e);
      }
    });
  }
  removeItem(key) {
    return new Promise((res) => {
      localStorage.removeItem(`${PREFIX}/${this.name}/${key}`);
      res();
    });
  }
};
function createAsyncLocalStorage(name) {
  return new AsyncLocalStorage(name);
}
var DEFAULT_DAPP_META = {
  name: "thirdweb powered dApp",
  url: "https://thirdweb.com",
  description: "thirdweb powered dApp",
  logoUrl: "https://thirdweb.com/favicon.ico",
  isDarkMode: true
};
var walletAnalyticsEnabled = true;
function isWalletAnalyticsEnabled() {
  return walletAnalyticsEnabled;
}
function setWalletAnalyticsEnabled(enabled) {
  walletAnalyticsEnabled = enabled;
}
var ANALYTICS_ENDPOINT = "https://c.thirdweb.com/event";
function track(args) {
  if (!isWalletAnalyticsEnabled()) {
    return;
  }
  const {
    clientId,
    walletType,
    walletAddress,
    source,
    action
  } = args;
  const body = {
    source,
    action,
    walletAddress,
    walletType
  };
  fetch(ANALYTICS_ENDPOINT, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-client-id": clientId,
      ...getAnalyticsHeaders()
    },
    body: JSON.stringify(body)
  });
}
var AbstractClientWallet = class extends AbstractWallet {
  getMeta() {
    return this.constructor.meta;
  }
  constructor(walletId, options) {
    super();
    this.walletId = walletId;
    this.options = options;
    this.chains = ((options == null ? void 0 : options.chains) || defaultChains).map((c) => updateChainRPCs(c, options == null ? void 0 : options.clientId));
    this.dappMetadata = (options == null ? void 0 : options.dappMetadata) || DEFAULT_DAPP_META;
    this.walletStorage = (options == null ? void 0 : options.walletStorage) || createAsyncLocalStorage(this.walletId);
  }
  async autoConnect(connectOptions) {
    const options = connectOptions ? {
      ...connectOptions,
      chainId: void 0
    } : void 0;
    return this._connect(true, options);
  }
  async connect(connectOptions) {
    this._connectParams = connectOptions;
    const address = await this._connect(false, connectOptions);
    if (!address) {
      throw new Error("Failed to connect to the wallet.");
    }
    return address;
  }
  getConnectParams() {
    return this._connectParams;
  }
  getOptions() {
    return this.options;
  }
  async _connect(isAutoConnect, connectOptions) {
    const connector = await this.getConnector();
    this._subscribeToEvents(connector);
    const isConnected = await connector.isConnected();
    if (isConnected) {
      const address = await connector.getAddress();
      connector.setupListeners();
      if (connectOptions == null ? void 0 : connectOptions.chainId) {
        await connector.switchChain(connectOptions == null ? void 0 : connectOptions.chainId);
      }
      this.emit("connect", {
        address,
        chainId: await this.getChainId()
      });
      this._trackConnection(address);
      return address;
    }
    if (isAutoConnect) {
      throw new Error("Failed to auto connect to the wallet.");
    }
    try {
      const address = await connector.connect(connectOptions);
      this._trackConnection(address);
      return address;
    } catch (error) {
      throw new Error(error.message);
    }
  }
  _trackConnection(address) {
    var _a;
    track({
      clientId: ((_a = this.options) == null ? void 0 : _a.clientId) || "",
      source: "connectWallet",
      action: "connect",
      walletType: this.walletId,
      walletAddress: address
    });
  }
  async _subscribeToEvents(connector) {
    connector.on("connect", (data) => {
      var _a;
      this.emit("connect", {
        address: data.account,
        chainId: (_a = data.chain) == null ? void 0 : _a.id
      });
    });
    connector.on("change", (data) => {
      var _a;
      this.emit("change", {
        address: data.account,
        chainId: (_a = data.chain) == null ? void 0 : _a.id
      });
    });
    connector.on("message", (data) => {
      this.emit("message", data);
    });
    connector.on("disconnect", async () => {
      this.emit("disconnect");
    });
    connector.on("error", (error) => this.emit("error", error));
  }
  async getSigner() {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    return await connector.getSigner();
  }
  async disconnect() {
    const connector = await this.getConnector();
    if (connector) {
      await connector.disconnect();
      this.emit("disconnect");
      connector.removeAllListeners();
    }
  }
  async switchChain(chainId) {
    const connector = await this.getConnector();
    if (!connector) {
      throw new Error("Wallet not connected");
    }
    if (!connector.switchChain) {
      throw new Error("Wallet does not support switching chains");
    }
    return await connector.switchChain(chainId);
  }
  async updateChains(chains) {
    this.chains = chains.map((c) => {
      var _a;
      return updateChainRPCs(c, (_a = this.options) == null ? void 0 : _a.clientId);
    });
    const connector = await this.getConnector();
    connector.updateChains(this.chains);
  }
  getPersonalWallet() {
    return void 0;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/blocto/dist/thirdweb-dev-wallets-evm-wallets-blocto.browser.esm.js
init_shim();
init_lib3();
var BloctoWallet = class extends AbstractClientWallet {
  constructor(options) {
    if ((options == null ? void 0 : options.chain) && options.clientId) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    super(BloctoWallet.id, options);
    _defineProperty(this, "name", "Blocto");
  }
  async initConnector() {
    var _a, _b, _c;
    const {
      BloctoConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-blocto.browser.esm-FGQYDIIX.js");
    const bloctoConnector = new BloctoConnector({
      chains: this.chains,
      options: {
        appId: (_a = this.options) == null ? void 0 : _a.appId,
        chainId: (_c = (_b = this.options) == null ? void 0 : _b.chain) == null ? void 0 : _c.chainId
      }
    });
    this.connector = new WagmiAdapter(bloctoConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initConnector();
    }
    return Promise.resolve(this.connector);
  }
};
_defineProperty(BloctoWallet, "id", walletIds.blocto);
_defineProperty(BloctoWallet, "meta", {
  name: "Blocto",
  iconURL: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHZpZXdCb3g9IjAgMCA2MCA2MCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwXzIyMzNfMjM4NykiPgo8cmVjdCB3aWR0aD0iNjAiIGhlaWdodD0iNjAiIHJ4PSIxMiIgZmlsbD0id2hpdGUiLz4KPHBhdGggZD0iTTMyLjkwMjggMTguMzA2M0MyOC4zOTExIDE4LjMwNjMgMjMuOTg3MyAyMC4wNDU5IDIwLjY5NTIgMjMuMTMxOUMxNy4wODQzIDI2LjUxNzYgMTQuNzk5MiAzMS41MTc3IDEzLjQ4OTMgMzYuMjIxMkMxMi42MzE0IDM5LjI5OTIgMTIuMjAxNiA0Mi40OTE1IDEyLjIwMTYgNDUuNjg1M0MxMi4yMDE2IDQ2LjY1MTEgMTIuMjQxMiA0Ny42MDg5IDEyLjMxNzQgNDguNTU1NkMxMi40MTA5IDQ5LjcwNjkgMTMuNTMyMSA1MC41MDQ2IDE0LjY0ODUgNTAuMjAzM0MxNS42MjIyIDQ5Ljk0MTYgMTYuNjQ2NiA0OS44MDA1IDE3LjcwMjggNDkuODAwNUMxOS44NzIyIDQ5LjgwMDUgMjEuOTA1MiA1MC4zOTA0IDIzLjY0OCA1MS40MjEyQzIzLjY5MDggNTEuNDQ2NiAyMy43MzIgNTEuNDcxOSAyMy43NzQ4IDUxLjQ5NTdDMjYuNjA3MSA1My4xODQ2IDI5Ljk0ODQgNTQuMTEyMyAzMy41MTE3IDUzLjk5MzRDNDIuODA2MiA1My42ODU3IDUwLjM5OSA0Ni4xMjMgNTAuNzQxNiAzNi44MzAxQzUxLjExNTggMjYuNjYzNSA0Mi45ODY5IDE4LjMwNDcgMzIuOTA0NCAxOC4zMDQ3TDMyLjkwMjggMTguMzA2M1pNMzIuOTAyOCA0NC4zMTJDMjguMzk3NSA0NC4zMTIgMjQuNzQ1NCA0MC42NTk5IDI0Ljc0NTQgMzYuMTU2MkMyNC43NDU0IDMxLjY1MjUgMjguMzk3NSAyNy45OTg3IDMyLjkwMjggMjcuOTk4N0MzNy40MDgxIDI3Ljk5ODcgNDEuMDYwMiAzMS42NTA5IDQxLjA2MDIgMzYuMTU2MkM0MS4wNjAyIDQwLjY2MTQgMzcuNDA4MSA0NC4zMTIgMzIuOTAyOCA0NC4zMTJaIiBmaWxsPSIjMTRBQUZGIi8+CjxwYXRoIGQ9Ik0yNS41NjM2IDEyLjY4MjZDMjUuNTYzNiAxNS4wMzQ0IDI0LjMzMTUgMTcuMjE2NCAyMi4zMDggMTguNDE1M0MyMS4wMzc3IDE5LjE2ODYgMTkuODQ2OCAyMC4wNTgyIDE4Ljc2ODQgMjEuMDcxNUMxNi4zNzU1IDIzLjMxMzkgMTQuNTg5OCAyNi4wNjUzIDEzLjI2NzMgMjguNzkyOUMxMy4wMDcyIDI5LjMzMDQgMTIuMiAyOS4xNDAyIDEyLjIgMjguNTQyM1YxMi42ODI2QzEyLjIgOC45OTI0MiAxNS4xOTI0IDYgMTguODgyNiA2QzIyLjU3MjggNiAyNS41NjUyIDguOTkyNDIgMjUuNTY1MiAxMi42ODI2SDI1LjU2MzZaIiBmaWxsPSIjMDA3NUZGIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDBfMjIzM18yMzg3Ij4KPHJlY3Qgd2lkdGg9IjYwIiBoZWlnaHQ9IjYwIiBmaWxsPSJ3aGl0ZSIvPgo8L2NsaXBQYXRoPgo8L2RlZnM+Cjwvc3ZnPgo=",
  urls: {
    android: "https://play.google.com/store/apps/details?id=com.portto.blocto",
    ios: "https://apps.apple.com/app/blocto/id1481181682"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/metamask/dist/thirdweb-dev-wallets-evm-wallets-metamask.browser.esm.js
init_shim();
init_lib3();
var MetaMaskWallet = class extends AbstractClientWallet {
  get walletName() {
    return "MetaMask";
  }
  constructor(options) {
    super(MetaMaskWallet.id, options);
    this.isInjected = !!getInjectedMetamaskProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          MetaMaskConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-metamask.browser.esm-XVUQTPZP.js");
        const metamaskConnector = new MetaMaskConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.metamaskConnector = metamaskConnector;
        this.connector = new WagmiAdapter(metamaskConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-QDMQ527N.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  async switchAccount() {
    if (!this.metamaskConnector) {
      throw new Error("Can not switch Account");
    }
    await this.metamaskConnector.switchAccount();
  }
};
_defineProperty(MetaMaskWallet, "meta", {
  name: "MetaMask",
  iconURL: "ipfs://QmZZHcw7zcXursywnLDAyY6Hfxzqop5GKgwoq8NB9jjrkN/metamask.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
    android: "https://play.google.com/store/apps/details?id=io.metamask",
    ios: "https://apps.apple.com/us/app/metamask-blockchain-wallet/id1438144202"
  }
});
_defineProperty(MetaMaskWallet, "id", walletIds.metamask);

// node_modules/@thirdweb-dev/wallets/evm/wallets/okx/dist/thirdweb-dev-wallets-evm-wallets-okx.browser.esm.js
init_shim();
init_lib3();
var OKXWallet = class extends AbstractClientWallet {
  get walletName() {
    return "OKX";
  }
  constructor(options) {
    super(OKXWallet.id, options);
    this.isInjected = !!getInjectedOKXProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          OKXConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-okx.browser.esm-MCWEURQK.js");
        this.OKXConnector = new OKXConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.OKXConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-QDMQ527N.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(OKXWallet, "id", walletIds.okx);

// node_modules/@thirdweb-dev/wallets/evm/wallets/core-wallet/dist/thirdweb-dev-wallets-evm-wallets-core-wallet.browser.esm.js
init_shim();
init_lib3();
var CoreWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Core wallet";
  }
  constructor(options) {
    super(CoreWallet.id, options);
    this.isInjected = !!getInjectedCoreWalletProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          CoreWalletConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-core-wallet.browser.esm-44DUH5JZ.js");
        this.CoreWalletConnector = new CoreWalletConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.CoreWalletConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-QDMQ527N.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(CoreWallet, "id", walletIds.coreWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/onekey/dist/thirdweb-dev-wallets-evm-wallets-onekey.browser.esm.js
init_shim();
init_lib3();
var OneKeyWallet = class extends AbstractClientWallet {
  get walletName() {
    return "OneKey wallet";
  }
  constructor(options) {
    super(OneKeyWallet.id, options);
    this.isInjected = !!getInjectedOneKeyProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          OneKeyConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-onekey.browser.esm-QQVINLSF.js");
        this.OneKeyConnector = new OneKeyConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.OneKeyConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-QDMQ527N.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(OneKeyWallet, "id", walletIds.oneKey);

// node_modules/@thirdweb-dev/wallets/evm/wallets/crypto-defi-wallet/dist/thirdweb-dev-wallets-evm-wallets-crypto-defi-wallet.browser.esm.js
init_shim();
init_lib3();
var CryptoDefiWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Crypto Defi wallet";
  }
  constructor(options) {
    super(CryptoDefiWallet.id, options);
    this.isInjected = !!getInjectedCryptoDefiWalletProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          CryptoDefiWalletConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-crypto-defi-wallet.browser.esm-F4FVXPC2.js");
        this.CryptoDefiWalletConnector = new CryptoDefiWalletConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.CryptoDefiWalletConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-QDMQ527N.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(CryptoDefiWallet, "id", walletIds.cryptoDefiWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/rabby/dist/thirdweb-dev-wallets-evm-wallets-rabby.browser.esm.js
init_shim();
init_lib3();
var RabbyWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Rabby wallet";
  }
  constructor(options) {
    super(RabbyWallet.id, options);
    this.isInjected = !!getInjectedRabbyProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          RabbyConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-rabby.browser.esm-OE4S2SXW.js");
        this.RabbyConnector = new RabbyConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.RabbyConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-QDMQ527N.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(RabbyWallet, "id", walletIds.rabby);

// node_modules/@thirdweb-dev/wallets/evm/wallets/coin98/dist/thirdweb-dev-wallets-evm-wallets-coin98.browser.esm.js
init_shim();
init_lib3();
var Coin98Wallet = class extends AbstractClientWallet {
  get walletName() {
    return "Coin98 wallet";
  }
  constructor(options) {
    super(Coin98Wallet.id, options);
    this.isInjected = !!getInjectedCoin98Provider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          Coin98Connector
        } = await import("./thirdweb-dev-wallets-evm-connectors-coin98.browser.esm-BH3A2QZB.js");
        this.Coin98Connector = new Coin98Connector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.connector = new WagmiAdapter(this.Coin98Connector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-QDMQ527N.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(Coin98Wallet, "id", walletIds.coin98);

// node_modules/@thirdweb-dev/wallets/dist/getInjectedCoinbaseProvider-b24ac791.browser.esm.js
init_shim();
function getInjectedCoinbaseProvider() {
  var _a;
  function getReady(ethereum) {
    const isCoinbaseWallet = !!(ethereum == null ? void 0 : ethereum.isCoinbaseWallet);
    if (isCoinbaseWallet) {
      return ethereum;
    }
    if (ethereum && "overrideIsMetaMask" in ethereum) {
      if ("providerMap" in ethereum) {
        if (ethereum.providerMap instanceof Map) {
          if (ethereum.providerMap.has("CoinbaseWallet")) {
            return ethereum;
          }
        }
      }
    }
  }
  if (assertWindowEthereum(globalThis.window)) {
    if ((_a = globalThis.window.ethereum) == null ? void 0 : _a.providers) {
      return globalThis.window.ethereum.providers.find(getReady);
    }
    return getReady(globalThis.window.ethereum);
  }
}

// node_modules/@thirdweb-dev/wallets/dist/engine-5c4a2a27.browser.esm.js
init_shim();
init_lib3();
var EngineSigner = class extends ethers_exports.Signer {
  constructor(config, provider) {
    super();
    this.config = {
      ...config,
      engineUrl: config.engineUrl.replace(/\/$/, "")
    };
    ethers_exports.utils.defineReadOnly(this, "provider", provider || null);
  }
  async getAddress() {
    return this.config.backendWalletAddress;
  }
  async signMessage(message) {
    const res = await this.fetch({
      path: "/backend-wallet/sign-message",
      method: "POST",
      body: {
        message
      }
    });
    return res.result;
  }
  async signTransaction(transaction) {
    var _a, _b, _c, _d, _e, _f;
    const tx = await ethers_exports.utils.resolveProperties(transaction);
    const res = await this.fetch({
      path: "/backend-wallet/sign-transaction",
      method: "POST",
      body: {
        ...tx,
        nonce: (_a = tx.nonce) == null ? void 0 : _a.toString(),
        gasLimit: (_b = tx.gasLimit) == null ? void 0 : _b.toString(),
        gasPrice: (_c = tx.gasPrice) == null ? void 0 : _c.toString(),
        value: (_d = tx.value) == null ? void 0 : _d.toString(),
        maxPriorityFeePerGas: (_e = tx.maxPriorityFeePerGas) == null ? void 0 : _e.toString(),
        maxFeePerGas: (_f = tx.maxFeePerGas) == null ? void 0 : _f.toString()
      }
    });
    return res.result;
  }
  async sendTransaction(transaction) {
    if (!this.provider) {
      throw new Error("Sending transactions requires a provider!");
    }
    const chainId = (await this.provider.getNetwork()).chainId;
    const tx = await ethers_exports.utils.resolveProperties(transaction);
    const res = await this.fetch({
      path: `/backend-wallet/${chainId}/send-transaction`,
      method: "POST",
      body: {
        toAddress: tx.to,
        data: tx.data,
        value: tx.value || "0"
      }
    });
    const queueId = res.result.queueId;
    return {
      hash: queueId,
      confirmations: 0,
      from: this.config.backendWalletAddress,
      nonce: 0,
      gasLimit: BigNumber.from(0),
      value: BigNumber.from(0),
      data: "",
      chainId,
      wait: async (confirmations) => {
        if (!this.provider) {
          throw new Error("Sending transactions requires a provider!");
        }
        while (true) {
          const {
            result: txRes
          } = await this.fetch({
            path: `/transaction/status/${queueId}`,
            method: "GET"
          });
          switch (txRes.status) {
            case "errored":
              throw new Error(`Transaction errored with reason: ${txRes.errorMessage}`);
            case "cancelled":
              throw new Error(`Transaction execution cancelled.`);
            case "mined":
              const receipt = await this.provider.getTransactionReceipt(txRes.transactionHash);
              return receipt;
          }
          await new Promise((resolve) => setTimeout(resolve, 1e3));
        }
      }
    };
  }
  connect(provider) {
    return new EngineSigner(this.config, provider);
  }
  async fetch(_ref) {
    let {
      path,
      method,
      body
    } = _ref;
    const res = await fetch(`${this.config.engineUrl}${path}`, {
      method,
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.config.accessToken}`,
        "x-backend-wallet-address": this.config.backendWalletAddress
      },
      ...body ? {
        body: JSON.stringify(body)
      } : {}
    });
    if (!res.ok) {
      throw new Error(await res.text());
    }
    return res.json();
  }
};
var EngineWallet = class extends AbstractWallet {
  constructor(config) {
    super();
    this._signer = new EngineSigner(config);
  }
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/paper-wallet/dist/thirdweb-dev-wallets-evm-wallets-paper-wallet.browser.esm.js
init_shim();
init_lib3();
var PaperWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Paper Wallet";
  }
  constructor(options) {
    var _a, _b;
    super(PaperWallet.id, {
      ...options
    });
    try {
      this.chain = {
        ...options.chain,
        rpc: getValidChainRPCs(options.chain, options.clientId)
      };
    } catch {
      this.chain = options.chain;
    }
    if (options.paperClientId && options.paperClientId === "uninitialized") {
      this.paperClientId = "00000000-0000-0000-0000-000000000000";
      return;
    }
    if (options.advancedOptions && ((_a = options.advancedOptions) == null ? void 0 : _a.recoveryShareManagement) === "USER_MANAGED") {
      if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId) || !options.paperClientId && options.clientId && !this.isClientIdLegacyPaper(options.clientId)) {
        throw new Error('RecoveryShareManagement option "USER_MANAGED" is not supported with thirdweb client ID');
      }
    }
    if (!options.clientId && !options.paperClientId) {
      throw new Error("clientId or paperClientId is required");
    }
    if (options.paperClientId && !this.isClientIdLegacyPaper(options.paperClientId)) {
      throw new Error("paperClientId must be a legacy paper client ID");
    }
    if (options.clientId && this.isClientIdLegacyPaper(options.clientId)) {
      throw new Error("clientId must be a thirdweb client ID");
    }
    this.paperClientId = (_b = options.paperClientId) != null ? _b : options.clientId;
    this.onAuthSuccess = options.onAuthSuccess;
  }
  isClientIdLegacyPaper(clientId) {
    return clientId.indexOf("-") > 0 && clientId.length === 36;
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      const {
        PaperWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-paper.browser.esm-AV7VW337.js");
      this.connector = new PaperWalletConnector({
        clientId: this.paperClientId,
        chain: this.chain,
        chains: this.chains,
        onAuthSuccess: this.onAuthSuccess,
        advancedOptions: {
          recoveryShareManagement: (_b = (_a = this.options) == null ? void 0 : _a.advancedOptions) == null ? void 0 : _b.recoveryShareManagement
        },
        styles: (_c = this.options) == null ? void 0 : _c.styles
      });
    }
    return this.connector;
  }
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    if (typeof connectParams.googleLogin === "object") {
      return {
        ...connectParams,
        googleLogin: true
      };
    }
    return connectParams;
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  async getPaperSDK() {
    const connector = await this.getConnector();
    return connector.getPaperSDK();
  }
};
_defineProperty(PaperWallet, "id", walletIds.paper);
_defineProperty(PaperWallet, "meta", {
  name: "Paper Wallet",
  iconURL: "ipfs://QmNrLXtPoFrh4yjZbXui39zUMozS1oetpgU8dvZhFAxfRa/paper-logo-icon.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/coinbase-wallet/dist/thirdweb-dev-wallets-evm-wallets-coinbase-wallet.browser.esm.js
init_shim();
var import_buffer = __toESM(require_buffer());
init_lib3();
{
  window.Buffer = import_buffer.Buffer;
}
var CoinbaseWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Coinbase Wallet";
  }
  constructor(options) {
    super(CoinbaseWallet.id, options);
    this.headlessMode = (options == null ? void 0 : options.headlessMode) || false;
    this.theme = (options == null ? void 0 : options.theme) || this.dappMetadata.isDarkMode === false ? "light" : "dark";
  }
  async getConnector() {
    if (!this.connector) {
      const {
        CoinbaseWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-coinbase-wallet.browser.esm-JRP6TRCI.js");
      const cbConnector = new CoinbaseWalletConnector({
        chains: this.chains,
        options: {
          appName: this.dappMetadata.name,
          reloadOnDisconnect: false,
          darkMode: this.theme === "dark",
          headlessMode: this.headlessMode
        }
      });
      cbConnector.on("connect", () => {
      });
      this.coinbaseConnector = cbConnector;
      this.connector = new WagmiAdapter(cbConnector);
    }
    return this.connector;
  }
  async getQrUrl() {
    await this.getConnector();
    if (!this.coinbaseConnector) {
      throw new Error("Coinbase connector not initialized");
    }
    return this.coinbaseConnector.getQrUrl();
  }
};
_defineProperty(CoinbaseWallet, "meta", {
  iconURL: "ipfs://QmcJBHopbwfJcLqJpX2xEufSS84aLbF7bHavYhaXUcrLaH/coinbase.svg",
  name: "Coinbase Wallet",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad",
    android: "https://play.google.com/store/apps/details?id=org.toshi",
    ios: "https://apps.apple.com/us/app/coinbase-wallet-nfts-crypto/id1278383455"
  }
});
_defineProperty(CoinbaseWallet, "id", walletIds.coinbase);

// node_modules/@thirdweb-dev/wallets/evm/wallets/embedded-wallet/dist/thirdweb-dev-wallets-evm-wallets-embedded-wallet.browser.esm.js
init_shim();
init_lib3();
var EmbeddedWallet = class extends AbstractClientWallet {
  static async sendVerificationEmail(options) {
    const wallet = new EmbeddedWallet({
      chain: c1,
      clientId: options.clientId
    });
    return wallet.sendVerificationEmail({
      email: options.email
    });
  }
  get walletName() {
    return "Embedded Wallet";
  }
  constructor(options) {
    super(EmbeddedWallet.id, {
      ...options
    });
    try {
      this.chain = {
        ...options.chain,
        rpc: getValidChainRPCs(options.chain, options.clientId)
      };
    } catch {
      this.chain = options.chain;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      const {
        EmbeddedWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-embedded-wallet.browser.esm-4FUDAU5B.js");
      this.connector = new EmbeddedWalletConnector({
        clientId: (_b = (_a = this.options) == null ? void 0 : _a.clientId) != null ? _b : "",
        chain: this.chain,
        chains: this.chains,
        onAuthSuccess: (_c = this.options) == null ? void 0 : _c.onAuthSuccess
      });
    }
    return this.connector;
  }
  autoConnect(connectOptions) {
    if (!connectOptions) {
      throw new Error("Can't autoconnect embedded wallet");
    }
    return this.connect(connectOptions);
  }
  getConnectParams() {
    const connectParams = super.getConnectParams();
    if (!connectParams) {
      return void 0;
    }
    return {
      chainId: connectParams.chainId,
      authResult: {
        user: connectParams.authResult.user
      }
    };
  }
  async getEmail() {
    const connector = await this.getConnector();
    return connector.getEmail();
  }
  async getEmbeddedWalletSDK() {
    const connector = await this.getConnector();
    return connector.getEmbeddedWalletSDK();
  }
  async getRecoveryInformation() {
    const connector = await this.getConnector();
    return connector.getRecoveryInformation();
  }
  async sendVerificationEmail(options) {
    const {
      email
    } = options;
    const connector = await this.getConnector();
    return connector.sendVerificationEmail({
      email
    });
  }
  async authenticate(params) {
    const connector = await this.getConnector();
    const authResult = connector.authenticate(params);
    try {
      await this.walletStorage.setItem(LAST_USED_AUTH_STRATEGY, params.strategy);
    } catch {
    }
    return authResult;
  }
  async getLastUsedAuthStrategy() {
    try {
      return await this.walletStorage.getItem(LAST_USED_AUTH_STRATEGY);
    } catch {
      return null;
    }
  }
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(EmbeddedWallet, "id", walletIds.embeddedWallet);
_defineProperty(EmbeddedWallet, "meta", {
  name: "Embedded Wallet",
  iconURL: "ipfs://QmNx2evQa6tcQs9VTd3YaDm31ckfStvgRGKFGELahUmrbV/emailIcon.svg"
});
var LAST_USED_AUTH_STRATEGY = "lastUsedAuthStrategy";

// node_modules/@thirdweb-dev/wallets/evm/wallets/ethers/dist/thirdweb-dev-wallets-evm-wallets-ethers.browser.esm.js
init_shim();
init_lib3();
var EthersWallet = class extends AbstractWallet {
  constructor(signer) {
    super();
    this._signer = signer;
  }
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/frame/dist/thirdweb-dev-wallets-evm-wallets-frame.browser.esm.js
init_shim();
init_lib3();
var FrameWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Frame Wallet";
  }
  constructor(options) {
    super(FrameWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        FrameConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-frame.browser.esm-45ESGNDW.js");
      this.connector = new WagmiAdapter(new FrameConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(FrameWallet, "id", walletIds.frame);

// node_modules/@thirdweb-dev/wallets/evm/wallets/injected/dist/thirdweb-dev-wallets-evm-wallets-injected.browser.esm.js
init_shim();
init_lib3();
var InjectedWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Injected Wallet";
  }
  constructor(options) {
    super(InjectedWallet.id, options);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        InjectedConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-injected.browser.esm-TTNEHAPM.js");
      this.connector = new WagmiAdapter(new InjectedConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      }));
    }
    return this.connector;
  }
};
_defineProperty(InjectedWallet, "id", "injected");

// node_modules/@thirdweb-dev/wallets/evm/wallets/local-wallet/dist/thirdweb-dev-wallets-evm-wallets-local-wallet.browser.esm.js
init_shim();
init_lib3();
var STORAGE_KEY_WALLET_DATA = "localWalletData";
var LocalWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Local Wallet";
  }
  constructor(options) {
    super(LocalWallet.id, options);
    if ((options == null ? void 0 : options.chain) && options.clientId) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    this.options = options || {};
    this._storage = (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        LocalWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-local-wallet.browser.esm-7G7AET4P.js");
      if (!this.ethersWallet) {
        throw new Error("wallet is not initialized");
      }
      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map((c) => updateChainRPCs(c, this.options.clientId));
      this.connector = new LocalWalletConnector({
        chain: this.options.chain || updateChainRPCs(c1, this.options.clientId),
        ethersWallet: this.ethersWallet,
        chains: this.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
  async loadOrCreate(options) {
    if (await this.getSavedData(options.storage)) {
      await this.load(options);
    } else {
      await this.generate();
      await this.save(options);
    }
  }
  async generate() {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const random = utils_exports.randomBytes(32);
    this.ethersWallet = new Wallet(random);
    return this.ethersWallet.address;
  }
  async import(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    if ("encryptedJson" in options) {
      this.ethersWallet = await Wallet.fromEncryptedJson(options.encryptedJson, options.password);
      return this.ethersWallet.address;
    }
    if ("privateKey" in options) {
      if (!options.encryption && !isValidPrivateKey(options.privateKey)) {
        throw new Error("invalid private key");
      }
      const privateKey = await getDecryptor(options.encryption)(options.privateKey);
      if (options.encryption && (privateKey === "" || !isValidPrivateKey(privateKey))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = new Wallet(privateKey);
      return this.ethersWallet.address;
    }
    if ("mnemonic" in options) {
      if (!options.encryption && !utils_exports.isValidMnemonic(options.mnemonic)) {
        throw new Error("invalid mnemonic");
      }
      const mnemonic = await getDecryptor(options.encryption)(options.mnemonic);
      if (options.encryption && (mnemonic === "" || !utils_exports.isValidMnemonic(mnemonic))) {
        throw new Error("invalid password");
      }
      this.ethersWallet = Wallet.fromMnemonic(mnemonic);
      return this.ethersWallet.address;
    }
    throw new Error("invalid import strategy");
  }
  async load(options) {
    if (this.ethersWallet) {
      throw new Error("wallet is already initialized");
    }
    const walletData = await this.getSavedData(options.storage);
    if (!walletData) {
      throw new Error("No Saved wallet found in storage");
    }
    if (walletData.strategy !== options.strategy) {
      throw new Error(`Saved wallet data is not ${options.strategy}, it is ${walletData.strategy}`);
    }
    if (options.strategy === "encryptedJson") {
      return this.import({
        encryptedJson: walletData.data,
        password: options.password
      });
    }
    if (walletData.isEncrypted && !options.encryption) {
      throw new Error("Saved wallet data is encrypted, but no password is provided");
    }
    if (!walletData.isEncrypted && options.encryption) {
      throw new Error("Saved wallet data is not encrypted, but encryption config is provided");
    }
    if (options.strategy === "privateKey") {
      return this.import({
        privateKey: walletData.data,
        encryption: options.encryption
      });
    }
    if (options.strategy === "mnemonic") {
      return this.import({
        mnemonic: walletData.data,
        encryption: options.encryption
      });
    }
    throw new Error("invalid load strategy");
  }
  async save(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      const encryptedData = await wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
      await this._saveData({
        address: wallet.address,
        data: encryptedData,
        strategy: "encryptedJson",
        isEncrypted: true
      }, options.storage);
    }
    if (options.strategy === "privateKey") {
      const privateKey = await getEncryptor(options.encryption)(wallet.privateKey);
      await this._saveData({
        address: wallet.address,
        data: privateKey,
        strategy: "privateKey",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      const mnemonic = await getEncryptor(options.encryption)(wallet.mnemonic.phrase);
      await this._saveData({
        address: wallet.address,
        data: mnemonic,
        strategy: "mnemonic",
        isEncrypted: !!options.encryption
      }, options.storage);
    }
  }
  async isSaved() {
    try {
      const data = await this.getSavedData();
      const address = await this.getAddress();
      if ((data == null ? void 0 : data.address) === address) {
        return true;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  async deleteSaved() {
    await this._storage.removeItem(STORAGE_KEY_WALLET_DATA);
  }
  async export(options) {
    const wallet = this.ethersWallet;
    if (!wallet) {
      throw new Error("Wallet is not initialized");
    }
    if (options.strategy === "encryptedJson") {
      return wallet.encrypt(options.password, {
        scrypt: {
          N: 1 << 32
        }
      });
    }
    if (options.strategy === "privateKey") {
      return getEncryptor(options.encryption)(wallet.privateKey);
    }
    if (options.strategy === "mnemonic") {
      if (!wallet.mnemonic) {
        throw new Error("mnemonic can not be computed if wallet is created from a private key or generated using generate()");
      }
      return getEncryptor(options.encryption)(wallet.mnemonic.phrase);
    }
    throw new Error("Invalid export strategy");
  }
  async getSavedData(storage) {
    const _storage = storage || this._storage;
    try {
      const savedDataStr = await _storage.getItem(STORAGE_KEY_WALLET_DATA);
      if (!savedDataStr) {
        return null;
      }
      const savedData = JSON.parse(savedDataStr);
      if (!savedData) {
        return null;
      }
      return savedData;
    } catch (e) {
      return null;
    }
  }
  async _saveData(data, storage) {
    const _storage = storage || this._storage;
    await _storage.setItem(STORAGE_KEY_WALLET_DATA, JSON.stringify(data));
  }
  async disconnect() {
    await super.disconnect();
    this.ethersWallet = void 0;
  }
};
_defineProperty(LocalWallet, "id", walletIds.localWallet);
_defineProperty(LocalWallet, "meta", {
  name: "Local Wallet",
  iconURL: "ipfs://QmbQzSNGvmNYZzem9jZRuYeLe9K2W4pqbdnVUp7Y6edQ8Y/local-wallet.svg"
});
async function noop(msg) {
  return msg;
}
function getDecryptor(encryption) {
  return encryption ? (msg) => (encryption.decrypt || aesDecryptCompat)(msg, encryption.password) : noop;
}
function getEncryptor(encryption) {
  return encryption ? (msg) => (encryption.encrypt || aesEncrypt)(msg, encryption.password) : noop;
}
function isValidPrivateKey(value) {
  return !!value.match(/^(0x)?[0-9a-f]{64}$/i);
}

// node_modules/@thirdweb-dev/wallets/evm/wallets/signer/dist/thirdweb-dev-wallets-evm-wallets-signer.browser.esm.js
init_shim();
init_lib3();
var SignerWallet = class extends AbstractClientWallet {
  constructor(options) {
    super("signerWallet", options);
    if (options.clientId && options.chain) {
      options.chain = updateChainRPCs(options.chain, options.clientId);
    }
    this.options = options;
    this.signer = options.signer;
    this._storage = (options == null ? void 0 : options.storage) || createAsyncLocalStorage(walletIds.localWallet);
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SignerConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-signer.browser.esm-CP4XXE4Y.js");
      if (!this.signer) {
        this.signer = this.options.signer;
      }
      const defaults = (this.options.chain ? [...defaultChains, this.options.chain] : defaultChains).map((c) => updateChainRPCs(c, this.options.clientId));
      this.connector = new SignerConnector({
        chain: this.options.chain || updateChainRPCs(c1, this.options.clientId),
        signer: this.signer,
        chains: this.chains || defaults,
        clientId: this.options.clientId,
        secretKey: this.options.secretKey
      });
    }
    return this.connector;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic/dist/thirdweb-dev-wallets-evm-wallets-magic.browser.esm.js
init_shim();
init_lib3();
var MagicLink = class extends AbstractClientWallet {
  get walletName() {
    return "Magic Link";
  }
  constructor(options) {
    super(MagicLink.id, options);
    this.options = options;
  }
  async initializeConnector() {
    const {
      MagicAuthConnector
    } = await import("./thirdweb-dev-wallets-evm-connectors-magic.browser.esm-QYHK4MWK.js");
    const magicConnector = new MagicAuthConnector({
      chains: this.chains,
      options: this.options
    });
    this.magicConnector = magicConnector;
    this.connector = new WagmiAdapter(magicConnector);
    return this.connector;
  }
  async getConnector() {
    if (!this.connector) {
      return await this.initializeConnector();
    }
    return this.connector;
  }
  getMagic() {
    if (!this.magicConnector) {
      throw new Error("Magic connector is not initialized");
    }
    return this.magicConnector.getMagicSDK();
  }
  async autoConnect(options) {
    var _a;
    await this.initializeConnector();
    await ((_a = this.magicConnector) == null ? void 0 : _a.initializeMagicSDK(options));
    const magic = this.getMagic();
    {
      const url = new URL(window.location.href);
      const isMagicRedirect = url.searchParams.get("magic_credential");
      if (isMagicRedirect) {
        try {
          this.oAuthRedirectResult = await magic.oauth.getRedirectResult();
        } catch {
        }
      }
    }
    const isLoggedIn = await magic.user.isLoggedIn();
    if (isLoggedIn) {
      return super.autoConnect(options);
    }
    throw new Error("Magic user is not logged in");
  }
  async disconnect() {
    this.oAuthRedirectResult = void 0;
    const magic = this.getMagic();
    await magic.user.logout();
    return super.disconnect();
  }
  async connect(options) {
    if ("email" in options && this.options.emailLogin === false) {
      throw new Error("Email login is disabled");
    }
    if ("phoneNumber" in options && this.options.smsLogin === false) {
      throw new Error("SMS login is disabled");
    }
    return super.connect(options);
  }
};
_defineProperty(MagicLink, "meta", {
  iconURL: "ipfs://QmUMBFZGXxBpgDmZzZAHhbcCL5nYvZnVaYLTajsNjLcxMU/1-Icon_Magic_Color.svg",
  name: "Magic Link"
});
_defineProperty(MagicLink, "id", walletIds.magicLink);

// node_modules/@thirdweb-dev/wallets/evm/wallets/xdefi/dist/thirdweb-dev-wallets-evm-wallets-xdefi.browser.esm.js
init_shim();
init_lib3();
var XDEFIWallet = class extends AbstractClientWallet {
  get walletName() {
    return "XDEFI";
  }
  constructor(options) {
    super(XDEFIWallet.id, options);
    this.isInjected = !!getInjectedXDEFIProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        XDEFIConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-xdefi.browser.esm-MTV3WEJD.js");
      const connector = new XDEFIConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.connector = new WagmiAdapter(connector);
    }
    return this.connector;
  }
};
_defineProperty(XDEFIWallet, "id", walletIds.xdefi);

// node_modules/@thirdweb-dev/wallets/evm/wallets/phantom/dist/thirdweb-dev-wallets-evm-wallets-phantom.browser.esm.js
init_shim();
init_lib3();
var PhantomWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Phantom";
  }
  constructor(options) {
    super(PhantomWallet.id, options);
    this.isInjected = !!getInjectedPhantomProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        PhantomConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-phantom.browser.esm-II5CVLQ6.js");
      const phantomConnector = new PhantomConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.phantomConnector = phantomConnector;
      this.connector = new WagmiAdapter(phantomConnector);
    }
    return this.connector;
  }
};
_defineProperty(PhantomWallet, "meta", {
  name: "Phantom",
  iconURL: "ipfs://bafybeibkpca5nwxpsjrtuxmz2ckb5lyc2sl2abg5f7dnvxku637vvffjti",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa"
  }
});
_defineProperty(PhantomWallet, "id", walletIds.phantom);

// node_modules/@thirdweb-dev/wallets/evm/wallets/private-key/dist/thirdweb-dev-wallets-evm-wallets-private-key.browser.esm.js
init_shim();
init_lib3();
var PrivateKeyWallet = class extends AbstractWallet {
  constructor(privateKey, chain, secretKey) {
    super();
    this._signer = new ethers_exports.Wallet(privateKey, chain ? getChainProvider(chain, {
      secretKey
    }) : void 0);
  }
  async getSigner() {
    return this._signer;
  }
};

// node_modules/@thirdweb-dev/wallets/evm/wallets/rainbow-wallet/dist/thirdweb-dev-wallets-evm-wallets-rainbow-wallet.browser.esm.js
init_shim();
init_lib3();
var RainbowWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Rainbow Wallet";
  }
  constructor(options) {
    super(RainbowWallet.id, options);
    this.isInjected = !!getInjectedRainbowProvider();
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          RainbowConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-rainbow.browser.esm-IIYJCLPQ.js");
        const rainbowConnector = new RainbowConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.rainbowConnector = rainbowConnector;
        this.connector = new WagmiAdapter(rainbowConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-QDMQ527N.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(RainbowWallet, "meta", {
  name: "Rainbow Wallet",
  iconURL: "ipfs://QmSZn47p4DVVBfzvg9BAX2EqwnPxkT1YAE7rUnrtd9CybQ/rainbow-logo.png",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/rainbow/opfgelmcmbiajamepnmloijbpoleiama",
    android: "https://rnbwapp.com/e/Va41HWS6Oxb",
    ios: "https://rnbwapp.com/e/OeMdmkJ6Oxb"
  }
});
_defineProperty(RainbowWallet, "id", walletIds.rainbow);

// node_modules/@thirdweb-dev/wallets/evm/wallets/safe/dist/thirdweb-dev-wallets-evm-wallets-safe.browser.esm.js
init_shim();
init_lib3();
var SafeWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Safe Wallet";
  }
  constructor(options) {
    super(SafeWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SafeConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-safe.browser.esm-UMVFPZKU.js");
      this.connector = new SafeConnector();
    }
    return this.connector;
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  autoConnect(params) {
    return this.connect(params);
  }
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(SafeWallet, "meta", {
  name: "Safe",
  iconURL: "ipfs://QmbbyxDDmmLQh8DzzeUR6X6B75bESsNUFmbdvS3ZsQ2pN1/SafeToken.svg"
});
_defineProperty(SafeWallet, "id", walletIds.safe);

// node_modules/@thirdweb-dev/wallets/evm/wallets/smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-smart-wallet.browser.esm.js
init_shim();
init_lib3();
var import_contracts = __toESM(require_dist());
var sdkCache = /* @__PURE__ */ new Map();
function getSDK(chain) {
  const cached = sdkCache.get(chain);
  if (cached) {
    return cached;
  }
  const sdk = new ThirdwebSDK(chain);
  sdkCache.set(chain, sdk);
  return sdk;
}
async function getAllSigners(chain, factoryAddress, smartWalletAddress) {
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const signers = await factoryContract.call("getSignersOfAccount", [smartWalletAddress]);
  return signers;
}
async function getAllSmartWallets(chain, factoryAddress, personalWalletAddress) {
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const ownedAccount = await getSmartWalletAddress(chain, factoryAddress, personalWalletAddress);
  const accessibleAccounts = await factoryContract.call("getAccountsOfSigner", [personalWalletAddress]);
  return {
    owned: ownedAccount,
    hasSignerRole: accessibleAccounts
  };
}
async function isSmartWalletDeployed(chain, factoryAddress, personalWalletAddress) {
  let data = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "0x";
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const accountAddress = await factoryContract.call("getAddress", [personalWalletAddress, data]);
  const isDeployed = await isContractDeployed(accountAddress, readOnlySDK.getProvider());
  return isDeployed;
}
async function getSmartWalletAddress(chain, factoryAddress, personalWalletAddress) {
  let data = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : "0x";
  const readOnlySDK = getSDK(chain);
  const factoryContract = await readOnlySDK.getContract(factoryAddress);
  const accountAddress = await factoryContract.call("getAddress", [personalWalletAddress, data]);
  return accountAddress;
}
async function getUserOpReceipt(chain, userOpHash) {
  let timeout = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3e4;
  let interval = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 2e3;
  let entryPointAddress = arguments.length > 4 ? arguments[4] : void 0;
  const readOnlySDK = getSDK(chain);
  const entrypoint = await readOnlySDK.getContract(entryPointAddress || ENTRYPOINT_ADDRESS, import_contracts.EntryPoint__factory.abi);
  const pastEvents = await entrypoint.events.getEvents("UserOperationEvent", {
    fromBlock: -9e3,
    filters: {
      userOpHash
    }
  });
  if (pastEvents[0]) {
    return pastEvents[0].transaction.transactionHash;
  }
  const endtime = Date.now() + timeout;
  while (Date.now() < endtime) {
    const events = await entrypoint.events.getEvents("UserOperationEvent", {
      fromBlock: -100,
      filters: {
        userOpHash
      }
    });
    if (events[0]) {
      return events[0].transaction.transactionHash;
    }
    await new Promise((resolve) => setTimeout(resolve, interval));
  }
  return null;
}
var SmartWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Smart Wallet";
  }
  constructor(options) {
    if (options.clientId && typeof options.chain === "object") {
      try {
        options.chain = {
          ...options.chain,
          rpc: getValidChainRPCs(options.chain, options.clientId)
        };
      } catch {
      }
    }
    super(SmartWallet.id, {
      ...options
    });
  }
  async getConnector() {
    if (!this.connector) {
      const {
        SmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-smart-wallet.browser.esm-XV35TKR2.js");
      this.connector = new SmartWalletConnector(this.options);
    }
    return this.connector;
  }
  getPersonalWallet() {
    var _a;
    return (_a = this.connector) == null ? void 0 : _a.personalWallet;
  }
  async hasPermissionToExecute(transaction) {
    const connector = await this.getConnector();
    return connector.hasPermissionToExecute(transaction);
  }
  async send(transaction, options) {
    const connector = await this.getConnector();
    return connector.send(transaction, options);
  }
  async execute(transaction, options) {
    const connector = await this.getConnector();
    return connector.execute(transaction, options);
  }
  async sendBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.sendBatch(transactions, options);
  }
  async executeBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.executeBatch(transactions, options);
  }
  async sendRaw(transaction, options) {
    const connector = await this.getConnector();
    return connector.sendRaw(transaction, options);
  }
  async executeRaw(transaction, options) {
    const connector = await this.getConnector();
    return connector.executeRaw(transaction, options);
  }
  async estimate(transaction, options) {
    const connector = await this.getConnector();
    return connector.estimate(transaction, options);
  }
  async estimateBatch(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateBatch(transactions, options);
  }
  async estimateRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateRaw(transactions, options);
  }
  async estimateBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.estimateBatchRaw(transactions, options);
  }
  async sendBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.sendBatchRaw(transactions, options);
  }
  async executeBatchRaw(transactions, options) {
    const connector = await this.getConnector();
    return connector.executeBatchRaw(transactions, options);
  }
  async deploy(options) {
    const connector = await this.getConnector();
    return connector.deploy(options);
  }
  async deployIfNeeded(options) {
    const connector = await this.getConnector();
    return connector.deployIfNeeded(options);
  }
  async isDeployed() {
    const connector = await this.getConnector();
    return connector.isDeployed();
  }
  async createSessionKey(keyAddress, permissions) {
    const connector = await this.getConnector();
    return connector.grantPermissions(keyAddress, permissions);
  }
  async revokeSessionKey(keyAddress) {
    const connector = await this.getConnector();
    return connector.revokePermissions(keyAddress);
  }
  async addAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.addAdmin(adminAddress);
  }
  async removeAdmin(adminAddress) {
    const connector = await this.getConnector();
    return connector.removeAdmin(adminAddress);
  }
  async getAllActiveSigners() {
    const connector = await this.getConnector();
    return connector.getAllActiveSigners();
  }
  async getAccountContract() {
    const connector = await this.getConnector();
    return connector.getAccountContract();
  }
  async getFactoryContract() {
    const connector = await this.getConnector();
    return connector.getFactoryContract();
  }
  async verifySignature(message, signature, address, chainId) {
    var _a, _b;
    try {
      const messageHash = utils_exports.hashMessage(message);
      const messageHashBytes = utils_exports.arrayify(messageHash);
      const recoveredAddress = utils_exports.recoverAddress(messageHashBytes, signature);
      if (recoveredAddress === address) {
        return true;
      }
    } catch {
    }
    if (chainId !== void 0) {
      try {
        return await checkContractWalletSignature(message, signature, address, chainId || 1, (_a = this.options) == null ? void 0 : _a.clientId, (_b = this.options) == null ? void 0 : _b.secretKey);
      } catch {
      }
    }
    return false;
  }
  autoConnect(params) {
    return this.connect(params);
  }
  connect(connectOptions) {
    return super.connect(connectOptions);
  }
};
_defineProperty(SmartWallet, "meta", {
  name: "Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(SmartWallet, "id", walletIds.smartWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/trust/dist/thirdweb-dev-wallets-evm-wallets-trust.browser.esm.js
init_shim();
init_lib3();
var TrustWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Trust Wallet";
  }
  constructor(options) {
    var _a;
    super(TrustWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isTrust);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          TrustConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-trust.browser.esm-2XIOLO4T.js");
        const trustConnector = new TrustConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.trustConnector = trustConnector;
        this.connector = new WagmiAdapter(trustConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-QDMQ527N.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(TrustWallet, "meta", {
  name: "Trust Wallet",
  iconURL: "ipfs://QmNigQbXk7wKZwDcgN38Znj1ZZQ3JEG3DD6fUKLBU8SUTP/trust%20wallet.svg",
  urls: {
    chrome: "https://chrome.google.com/webstore/detail/trust-wallet/egjidjbpglichdcondbcbdnbeeppgdph",
    android: "https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp",
    ios: "https://apps.apple.com/us/app/trust-crypto-bitcoin-wallet/id1288339409"
  }
});
_defineProperty(TrustWallet, "id", walletIds.trust);

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect.browser.esm.js
init_shim();
init_lib3();
var WalletConnect = class extends AbstractClientWallet {
  get walletName() {
    return "WalletConnect";
  }
  constructor(options) {
    super((options == null ? void 0 : options.walletId) || WalletConnect.id, options);
    _defineProperty(this, "_maybeThrowError", (error) => {
      if (error) {
        throw error;
      }
    });
    _defineProperty(this, "_onConnect", (data) => {
      this._provider = data.provider;
      if (!this._provider) {
        throw new Error("WalletConnect provider not found after connecting.");
      }
    });
    _defineProperty(this, "_onDisconnect", () => {
      this._removeListeners();
    });
    _defineProperty(this, "_onChange", async (payload) => {
      if (payload.chain)
        ;
      else if (payload.account)
        ;
    });
    _defineProperty(this, "_onMessage", (payload) => {
      switch (payload.type) {
        case "display_uri":
          this.emit("display_uri", payload.data);
          break;
      }
    });
    _defineProperty(this, "_onSessionRequestSent", () => {
      this.emit("wc_session_request_sent");
    });
    this.projectId = (options == null ? void 0 : options.projectId) || TW_WC_PROJECT_ID;
    this.qrcode = (options == null ? void 0 : options.qrcode) === false ? false : true;
  }
  async getConnector() {
    var _a;
    if (!this.connector) {
      const {
        WalletConnectConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-QDMQ527N.js");
      this._walletConnectConnector = new WalletConnectConnector({
        chains: this.chains,
        options: {
          qrcode: this.qrcode,
          projectId: this.projectId,
          dappMetadata: this.dappMetadata,
          storage: this.walletStorage,
          qrModalOptions: (_a = this.options) == null ? void 0 : _a.qrModalOptions
        }
      });
      this.connector = new WagmiAdapter(this._walletConnectConnector);
      this._provider = await this._walletConnectConnector.getProvider();
      this._setupListeners();
    }
    return this.connector;
  }
  _setupListeners() {
    var _a;
    if (!this._walletConnectConnector) {
      return;
    }
    this._removeListeners();
    this._walletConnectConnector.on("connect", this._onConnect);
    this._walletConnectConnector.on("disconnect", this._onDisconnect);
    this._walletConnectConnector.on("change", this._onChange);
    this._walletConnectConnector.on("message", this._onMessage);
    (_a = this._provider) == null ? void 0 : _a.signer.client.on("session_request_sent", this._onSessionRequestSent);
  }
  _removeListeners() {
    var _a;
    if (!this._walletConnectConnector) {
      return;
    }
    this._walletConnectConnector.removeListener("connect", this._onConnect);
    this._walletConnectConnector.removeListener("disconnect", this._onDisconnect);
    this._walletConnectConnector.removeListener("change", this._onChange);
    this._walletConnectConnector.removeListener("message", this._onMessage);
    (_a = this._provider) == null ? void 0 : _a.signer.client.removeListener("session_request_sent", this._onSessionRequestSent);
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this._walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    wcConnector.showWalletConnectModal = false;
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
  async connectWithModal(options) {
    await this.getConnector();
    const wcConnector = this._walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    wcConnector.showWalletConnectModal = true;
    await wcConnector.initProvider();
    await this.connect({
      chainId: options == null ? void 0 : options.chainId
    });
  }
};
_defineProperty(WalletConnect, "id", walletIds.walletConnect);
_defineProperty(WalletConnect, "meta", {
  name: "WalletConnect",
  iconURL: "ipfs://QmX58KPRaTC9JYZ7KriuBzeoEaV2P9eZcA3qbFnTHZazKw/wallet-connect.svg"
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/wallet-connect-v1/dist/thirdweb-dev-wallets-evm-wallets-wallet-connect-v1.browser.esm.js
init_shim();
init_lib3();
var WalletConnectV1 = WalletConnect;

// node_modules/@thirdweb-dev/wallets/evm/wallets/zerion/dist/thirdweb-dev-wallets-evm-wallets-zerion.browser.esm.js
init_shim();
init_lib3();
var ZerionWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Zerion Wallet";
  }
  constructor(options) {
    var _a;
    super(ZerionWallet.id, options);
    if (assertWindowEthereum(globalThis.window)) {
      this.isInjected = !!((_a = globalThis.window.ethereum) == null ? void 0 : _a.isZerion);
    } else {
      this.isInjected = false;
    }
  }
  async getConnector() {
    var _a, _b, _c;
    if (!this.connector) {
      if (this.isInjected) {
        const {
          ZerionConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-zerion.browser.esm-GQ43VBEZ.js");
        const zerionConnector = new ZerionConnector({
          chains: this.chains,
          connectorStorage: this.walletStorage,
          options: {
            shimDisconnect: true
          }
        });
        this.zerionConnector = zerionConnector;
        this.connector = new WagmiAdapter(zerionConnector);
      } else {
        const {
          WalletConnectConnector
        } = await import("./thirdweb-dev-wallets-evm-connectors-wallet-connect.browser.esm-QDMQ527N.js");
        const walletConnectConnector = new WalletConnectConnector({
          chains: this.chains,
          options: {
            projectId: ((_a = this.options) == null ? void 0 : _a.projectId) || TW_WC_PROJECT_ID,
            storage: this.walletStorage,
            qrcode: (_b = this.options) == null ? void 0 : _b.qrcode,
            dappMetadata: this.dappMetadata,
            qrModalOptions: (_c = this.options) == null ? void 0 : _c.qrModalOptions
          }
        });
        walletConnectConnector.getProvider().then((provider) => {
          provider.signer.client.on("session_request_sent", () => {
            this.emit("wc_session_request_sent");
          });
        });
        this.walletConnectConnector = walletConnectConnector;
        this.connector = new WagmiAdapter(walletConnectConnector);
      }
    }
    return this.connector;
  }
  async connectWithQrCode(options) {
    await this.getConnector();
    const wcConnector = this.walletConnectConnector;
    if (!wcConnector) {
      throw new Error("WalletConnect connector not found");
    }
    const wcProvider = await wcConnector.getProvider();
    wcProvider.on("display_uri", (uri) => {
      options.onQrCodeUri(uri);
    });
    this.connect({
      chainId: options.chainId
    }).then(options.onConnected);
  }
};
_defineProperty(ZerionWallet, "id", "zerion");
_defineProperty(ZerionWallet, "meta", {
  name: "Zerion Wallet",
  iconURL: "ipfs://Qmb1LhNtMUkzbgk1V8ZiUSRXjMJGRkS5HH3R71KyRgjdBG/zerion.png",
  urls: {
    chrome: "https://zerion.io/extension",
    android: "https://link.zerion.io/901o6IN0jqb",
    ios: "https://link.zerion.io/a11o6IN0jqb"
  }
});

// node_modules/@thirdweb-dev/wallets/evm/wallets/token-bound-smart-wallet/dist/thirdweb-dev-wallets-evm-wallets-token-bound-smart-wallet.browser.esm.js
init_shim();
init_lib3();
var import_contracts2 = __toESM(require_dist());
var TokenBoundSmartWallet = class extends SmartWallet {
  get walletName() {
    return "Token Bound Smart Wallet";
  }
  constructor(options) {
    super({
      ...options,
      factoryAddress: options.registryAddress || ERC6551_REGISTRY
    });
    this.tbaOptions = options;
  }
  async getConnector() {
    if (!this.tbaConnector) {
      const {
        TokenBoundSmartWalletConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-token-bound-smart-wallet.browser.esm-QIPI7A3W.js");
      this.tbaConnector = new TokenBoundSmartWalletConnector(this.tbaOptions);
    }
    return this.tbaConnector;
  }
};
_defineProperty(TokenBoundSmartWallet, "meta", {
  name: "Token Bound Smart Wallet",
  iconURL: "ipfs://QmeAJVqn17aDNQhjEU3kcWVZCFBrfta8LzaDGkS8Egdiyk/smart-wallet.svg"
});
_defineProperty(TokenBoundSmartWallet, "id", walletIds.tokenBoundSmartWallet);

// node_modules/@thirdweb-dev/wallets/evm/wallets/magic-eden/dist/thirdweb-dev-wallets-evm-wallets-magic-eden.browser.esm.js
init_shim();
init_lib3();
var MagicEdenWallet = class extends AbstractClientWallet {
  get walletName() {
    return "Magic Eden";
  }
  constructor(options) {
    super(MagicEdenWallet.id, options);
    this.isInjected = !!getInjectedMagicEdenProvider();
  }
  async getConnector() {
    if (!this.connector) {
      const {
        MagicEdenConnector
      } = await import("./thirdweb-dev-wallets-evm-connectors-magic-eden.browser.esm-FOVLB3WH.js");
      const connector = new MagicEdenConnector({
        chains: this.chains,
        connectorStorage: this.walletStorage,
        options: {
          shimDisconnect: true
        }
      });
      this.connector = new WagmiAdapter(connector);
    }
    return this.connector;
  }
};
_defineProperty(MagicEdenWallet, "id", walletIds.magicEden);

// node_modules/@thirdweb-dev/wallets/dist/thirdweb-dev-wallets.browser.esm.js
var import_buffer2 = __toESM(require_buffer());
var import_contracts3 = __toESM(require_dist());
var import_utils2 = __toESM(require_utils());
var PREFIX2 = "__TW__";
var LocalStorage = class {
  constructor(name) {
    this.name = name;
  }
  getItem(key) {
    return localStorage.getItem(`${PREFIX2}/${this.name}/${key}`);
  }
  setItem(key, value) {
    return localStorage.setItem(`${PREFIX2}/${this.name}/${key}`, value);
  }
  removeItem(key) {
    return localStorage.removeItem(`${PREFIX2}/${this.name}/${key}`);
  }
};
function createLocalStorage(name) {
  return new LocalStorage(name);
}
var WalletConnectHandler = class extends eventemitter3_default {
  constructor(wallet) {
    super();
    this.wallet = wallet;
  }
};
var WalletConnectV2Handler = class extends WalletConnectHandler {
  constructor(options, wallet) {
    super(wallet);
    const defaultWCReceiverConfig = {
      walletConnectWalletMetadata: {
        name: "Thirdweb Smart Wallet",
        description: "Thirdweb Smart Wallet",
        url: "https://thirdweb.com",
        icons: ["https://thirdweb.com/favicon.ico"]
      },
      walletConnectV2ProjectId: TW_WC_PROJECT_ID,
      walletConnectV2RelayUrl: WC_RELAY_URL,
      ...(options == null ? void 0 : options.walletConnectReceiver) === true ? {} : options == null ? void 0 : options.walletConnectReceiver
    };
    this._wcMetadata = defaultWCReceiverConfig.walletConnectWalletMetadata;
    this._core = new Mr({
      projectId: defaultWCReceiverConfig.walletConnectV2ProjectId,
      relayUrl: defaultWCReceiverConfig.walletConnectV2RelayUrl
    });
  }
  async init() {
    this._wcWallet = await V3.init({
      core: this._core,
      metadata: this._wcMetadata
    });
    const sessions = this._wcWallet.getActiveSessions();
    const keys = Object.keys(sessions);
    if (keys[0]) {
      this._session = sessions[keys[0]];
    }
    this._setupWalletConnectEventsListeners();
  }
  async connectApp(wcUri) {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before connecting an app.");
    }
    await this._wcWallet.core.pairing.pair({
      uri: wcUri
    });
  }
  async approveSession() {
    var _a;
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!this._activeProposal) {
      throw new Error("Please, pass a valid proposal.");
    }
    const account = await this.wallet.getAddress();
    const {
      id,
      params
    } = this._activeProposal;
    const {
      requiredNamespaces,
      relays
    } = params;
    const namespaces = {};
    Object.keys(requiredNamespaces).forEach((key) => {
      var _a2;
      const accounts = [];
      const namespace = requiredNamespaces[key];
      if (namespace) {
        (_a2 = namespace.chains) == null ? void 0 : _a2.map((chain) => {
          accounts.push(`${chain}:${account}`);
        });
        namespaces[key] = {
          accounts,
          methods: namespace.methods,
          events: namespace.events
        };
      }
    });
    this._session = await this._wcWallet.approveSession({
      id,
      relayProtocol: (_a = relays[0]) == null ? void 0 : _a.protocol,
      namespaces
    });
    this.emit("session_approved");
  }
  async rejectSession() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    if (!this._activeProposal) {
      throw new Error("Please, pass a valid proposal.");
    }
    const {
      id
    } = this._activeProposal;
    await this._wcWallet.rejectSession({
      id,
      reason: {
        message: "User rejected methods.",
        code: 5002
      }
    });
  }
  async approveEIP155Request() {
    var _a, _b;
    if (!this._activeRequestEvent) {
      return;
    }
    const {
      topic,
      params,
      id
    } = this._activeRequestEvent;
    const {
      request
    } = params;
    let response;
    switch (request.method) {
      case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
      case EIP155_SIGNING_METHODS.ETH_SIGN:
        const message = this._getSignParamsMessage(request.params);
        const signedMessage = await this.wallet.signMessage(message || "");
        response = formatJsonRpcResult(id, signedMessage);
        break;
      case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        const signer = await this.wallet.getSigner();
        const sendTransaction = request.params[0];
        const tx = await signer.sendTransaction(sendTransaction);
        const {
          transactionHash
        } = await tx.wait();
        response = formatJsonRpcResult(id, transactionHash);
        break;
      case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
        const signerSign = await this.wallet.getSigner();
        const signTransaction = request.params[0];
        const signature = await signerSign.signTransaction(signTransaction);
        response = formatJsonRpcResult(id, signature);
        break;
      default:
        const error = {
          id,
          jsonrpc: "2.0",
          error: {
            message: "Invalid event.",
            code: 1002
          }
        };
        return (_a = this._wcWallet) == null ? void 0 : _a.respondSessionRequest({
          topic,
          response: error
        });
    }
    return (_b = this._wcWallet) == null ? void 0 : _b.respondSessionRequest({
      topic,
      response
    });
  }
  async rejectEIP155Request() {
    var _a;
    if (!this._activeRequestEvent) {
      return;
    }
    const {
      topic,
      id
    } = this._activeRequestEvent;
    const response = {
      id,
      jsonrpc: "2.0",
      error: {
        message: "User rejected methods.",
        code: 5002
      }
    };
    return (_a = this._wcWallet) == null ? void 0 : _a.respondSessionRequest({
      topic,
      response
    });
  }
  getActiveSessions() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before getting sessions.");
    }
    const sessions = this._wcWallet.getActiveSessions();
    const sessionKeys = Object.keys(sessions);
    if (!sessions || sessionKeys.length === 0) {
      return [];
    }
    const thisSessions = [];
    for (const sessionKey of sessionKeys) {
      const session = sessions[sessionKey];
      if (session) {
        const topic = session.topic;
        const peerMeta = session.peer.metadata;
        thisSessions.push({
          topic,
          peer: {
            metadata: peerMeta
          }
        });
      }
    }
    return thisSessions;
  }
  disconnectSession() {
    var _a;
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before disconnecting sessions.");
    }
    if (!this._session) {
      return Promise.resolve();
    }
    const params = {
      topic: this._session.topic,
      reason: {
        message: "User disconnected.",
        code: 6e3
      }
    };
    return (_a = this._wcWallet) == null ? void 0 : _a.disconnectSession(params);
  }
  _setupWalletConnectEventsListeners() {
    if (!this._wcWallet) {
      throw new Error("Please, init the wallet before making session requests.");
    }
    this._wcWallet.on("session_proposal", (proposal) => {
      this._activeProposal = proposal;
      this.emit("session_proposal", {
        proposer: {
          metadata: proposal.params.proposer.metadata
        }
      });
    });
    this._wcWallet.on("session_delete", (session) => {
      this._session = void 0;
      this._activeProposal = void 0;
      this.emit("session_delete", {
        topic: session.topic
      });
    });
    this._wcWallet.on("session_request", async (requestEvent) => {
      if (!this._session) {
        return;
      }
      const {
        params: requestParams
      } = requestEvent;
      const {
        request
      } = requestParams;
      const {
        params
      } = request;
      switch (request.method) {
        case EIP155_SIGNING_METHODS.ETH_SIGN:
        case EIP155_SIGNING_METHODS.PERSONAL_SIGN:
          this._activeRequestEvent = requestEvent;
          const message = params[0];
          const decodedMessage = new TextDecoder().decode(utils_exports.arrayify(message));
          const paramsCopy = [...params];
          paramsCopy[0] = decodedMessage;
          this.emit("session_request", {
            topic: this._session.topic,
            params: paramsCopy,
            peer: {
              metadata: this._session.peer.metadata
            },
            method: request.method
          });
          return;
        case EIP155_SIGNING_METHODS.ETH_SEND_TRANSACTION:
        case EIP155_SIGNING_METHODS.ETH_SIGN_TRANSACTION:
          this._activeRequestEvent = requestEvent;
          this.emit("session_request", {
            topic: this._session.topic,
            params: requestEvent.params.request.params,
            peer: {
              metadata: this._session.peer.metadata
            },
            method: request.method
          });
          return;
        default:
          throw new Error(`WCV2.Method not supported: ${request.method}`);
      }
    });
  }
  _getSignParamsMessage(params) {
    const message = params.filter((p2) => !utils_exports.isAddress(p2))[0] || "";
    if (utils_exports.isHexString(message)) {
      return utils_exports.toUtf8String(message);
    }
    return message;
  }
};

export {
  EIP155_SIGNING_METHODS,
  AsyncLocalStorage,
  createAsyncLocalStorage,
  DEFAULT_DAPP_META,
  isWalletAnalyticsEnabled,
  setWalletAnalyticsEnabled,
  AbstractClientWallet,
  BloctoWallet,
  MetaMaskWallet,
  OKXWallet,
  CoreWallet,
  OneKeyWallet,
  CryptoDefiWallet,
  RabbyWallet,
  Coin98Wallet,
  getInjectedCoinbaseProvider,
  EngineSigner,
  EngineWallet,
  PaperWallet,
  CoinbaseWallet,
  EmbeddedWallet,
  EthersWallet,
  FrameWallet,
  InjectedWallet,
  LocalWallet,
  isValidPrivateKey,
  SignerWallet,
  MagicLink,
  XDEFIWallet,
  PhantomWallet,
  PrivateKeyWallet,
  RainbowWallet,
  SafeWallet,
  getAllSigners,
  getAllSmartWallets,
  isSmartWalletDeployed,
  getSmartWalletAddress,
  getUserOpReceipt,
  SmartWallet,
  TrustWallet,
  WalletConnect,
  WalletConnectV1,
  ZerionWallet,
  TokenBoundSmartWallet,
  MagicEdenWallet,
  LocalStorage,
  createLocalStorage,
  WalletConnectHandler,
  WalletConnectV2Handler
};
//# sourceMappingURL=chunk-IJIZJ54T.js.map
